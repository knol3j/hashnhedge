import { EOL } from "node:os";
import { format } from "node:util";
import { LogLevel, logger } from "@aigne/core/utils/logger.js";
import { mergeAgentResponseChunk } from "@aigne/core/utils/stream-utils.js";
import { color, DefaultRenderer, figures, Listr, ListrDefaultRendererLogLevels, ListrLogger, SimpleRenderer, Spinner, } from "@aigne/listr2";
import wrap from "wrap-ansi";
export class AIGNEListr extends Listr {
    myOptions;
    result = {};
    error;
    logs = [];
    spinner;
    constructor(myOptions, ...[task, options, parentTask]) {
        const aigneOptions = {
            getStdoutLogs: () => {
                return this.logs.splice(0);
            },
            getBottomBarLogs: (options) => {
                return this.myOptions.formatResult(this.result, options);
            },
        };
        super(task, {
            ...options,
            renderer: AIGNEListrRenderer,
            rendererOptions: {
                collapseSubtasks: false,
                icon: {
                    [ListrDefaultRendererLogLevels.PENDING]: () => this.spinner.fetch(),
                    [ListrDefaultRendererLogLevels.COMPLETED_WITH_FAILED_SUBTASKS]: figures.cross,
                },
                color: {
                    [ListrDefaultRendererLogLevels.COMPLETED_WITH_FAILED_SUBTASKS]: (m) => m ? color.red(m) : "",
                },
                aigne: aigneOptions,
            },
            fallbackRenderer: AIGNEListrFallbackRenderer,
            fallbackRendererOptions: {
                aigne: aigneOptions,
                logger: new (class extends ListrLogger {
                    log(...[level, ...args]) {
                        // ignore stdout logs if level `INFO` is not enabled
                        if (!this.options?.toStderr?.includes(level) && !logger.enabled(LogLevel.INFO)) {
                            return;
                        }
                        super.log(level, ...args);
                    }
                })(),
            },
        }, parentTask);
        this.myOptions = myOptions;
        this.spinner = new Spinner();
    }
    async run(stream) {
        const originalLog = logger.logMessage;
        const originalConsole = { ...console };
        try {
            this.ctx = {};
            this.spinner.start();
            if (logger.enabled(LogLevel.INFO)) {
                const request = this.myOptions.formatRequest();
                if (request)
                    console.log(request);
            }
            logger.logMessage = (...args) => this.logs.push(format(...args));
            for (const method of ["debug", "log", "info", "warn", "error"]) {
                console[method] = (...args) => {
                    const renderer = this["renderer"] instanceof AIGNEListrRenderer ? this["renderer"] : undefined;
                    const msg = format(...args);
                    renderer ? renderer.log(msg) : this.logs.push(msg);
                };
            }
            const _stream = await stream();
            this.add({ task: () => this.extractStream(_stream) });
            return await super.run().then(() => {
                if (this.error)
                    throw this.error;
                return { ...this.result };
            });
        }
        finally {
            logger.logMessage = originalLog;
            Object.assign(console, originalConsole);
            this.spinner.stop();
        }
    }
    async extractStream(stream) {
        try {
            this.result = {};
            for await (const value of stream) {
                mergeAgentResponseChunk(this.result, value);
            }
            return this.result;
        }
        catch (error) {
            this.error = error;
            throw error;
        }
    }
}
export class AIGNEListrRenderer extends DefaultRenderer {
    static rendererOptions = {
        ...DefaultRenderer.rendererOptions,
    };
    get _updater() {
        return this["updater"];
    }
    get _logger() {
        return this["logger"];
    }
    get _options() {
        return this["options"];
    }
    get _spinner() {
        return this["spinner"];
    }
    update() {
        if (this.paused || this.ended) {
            return;
        }
        this._updater(this.create({ running: true }));
    }
    paused = false;
    ended = false;
    end() {
        this.ended = true;
        super.end();
    }
    async pause() {
        this.paused = true;
        this._updater?.clear();
        this._updater?.done();
        await new Promise((resolve) => setTimeout(resolve, 100));
        this._logger.process.release();
    }
    async resume() {
        this._logger.process.hijack();
        this.paused = false;
    }
    log(message) {
        this._updater?.clear();
        this._logger.toStdout(message);
    }
    isPreviousPrompt = false;
    create({ running = false, ...options }) {
        const logs = this._options.aigne?.getStdoutLogs?.();
        if (logs?.length) {
            this._updater.clear();
            this._logger.toStdout(logs.join(EOL));
        }
        let buffer = "";
        const prompt = super["renderPrompt"]();
        if (prompt.length) {
            buffer += prompt.join(EOL);
            this.isPreviousPrompt = true;
        }
        // Skip a frame if previous render was a prompt, and reset the flag
        else if (this.isPreviousPrompt) {
            this.isPreviousPrompt = false;
        }
        else {
            buffer += super.create({ ...options, prompt: false });
            const bottomBar = this._options.aigne?.getBottomBarLogs?.({ running });
            if (bottomBar?.length) {
                buffer += EOL.repeat(2);
                const output = [...bottomBar, running ? this._spinner.fetch() : ""]
                    .map((i) => this._wrap(i))
                    .join(EOL);
                // If the task is not running, we show all lines
                if (!running) {
                    buffer += output;
                }
                // For running tasks, we only show the last few lines
                else {
                    const { rows } = process.stdout;
                    const lines = rows - buffer.split(EOL).length - 2;
                    buffer += output.split(EOL).slice(-Math.max(4, lines)).join(EOL);
                }
            }
        }
        return buffer;
    }
    _wrap(str) {
        return wrap(str, process.stdout.columns ?? 80, {
            hard: true,
            trim: false,
        });
    }
}
export class AIGNEListrFallbackRenderer extends SimpleRenderer {
    static rendererOptions = {
        ...SimpleRenderer.rendererOptions,
    };
    get _logger() {
        return this["logger"];
    }
    get _options() {
        return this["options"];
    }
    end() {
        const logs = [this._options.aigne?.getStdoutLogs?.(), this._options.aigne?.getBottomBarLogs?.()]
            .filter(Boolean)
            .flat()
            .join(EOL);
        if (logs)
            this._logger.toStdout(logs);
    }
}
