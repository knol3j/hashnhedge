import { type InspectOptions } from "node:util";
import { type Agent, type Context, type ContextUsage, type InvokeOptions, type Message } from "@aigne/core";
import { promiseWithResolvers } from "@aigne/core/utils/promise.js";
import { type Listr } from "@aigne/listr2";
import { type AIGNEListrTaskWrapper } from "../utils/listr.js";
export interface TerminalTracerOptions {
    outputKey?: string;
}
export declare class TerminalTracer {
    readonly context: Context;
    readonly options: TerminalTracerOptions;
    constructor(context: Context, options?: TerminalTracerOptions);
    private tasks;
    run(agent: Agent, input: Message, options?: InvokeOptions): Promise<{
        result: Message;
        context: Context<import("@aigne/core").UserContext>;
    }>;
    private listr?;
    private proxiedPrompts;
    private buyCreditsPromptPromise;
    private promptBuyCredits;
    formatTokenUsage(usage: Partial<ContextUsage>, extra?: {
        [key: string]: string;
    }): string;
    formatTimeUsage(startTime: number, endTime: number): string;
    formatTaskTitle(agent: Agent, { task, usage, time, input }: {
        task?: Task;
        usage?: boolean;
        time?: boolean;
        input: Message;
    }): Promise<string>;
    private marked;
    get outputKey(): string;
    formatRequest(agent: Agent, _context: Context, m?: Message, { running }?: {
        running?: boolean | undefined;
    }): string | undefined;
    formatResult(agent: Agent, context: Context, m?: Message, { running }?: {
        running?: boolean | undefined;
    }): string;
    protected runningInspectOptions: InspectOptions;
}
type Task = ReturnType<typeof promiseWithResolvers<void>> & {
    listr: ReturnType<typeof promiseWithResolvers<{
        ctx: object;
        subtask: Listr;
        taskWrapper: AIGNEListrTaskWrapper;
    }>>;
    agent: Agent;
    input: Message;
    startTime?: number;
    endTime?: number;
    usage?: Partial<ContextUsage>;
    extraTitleMetadata?: {
        [key: string]: string;
    };
};
export {};
