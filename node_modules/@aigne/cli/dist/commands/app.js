import assert from "node:assert";
import { spawn } from "node:child_process";
import { mkdir, readFile, rm, stat, writeFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { AIGNE } from "@aigne/core";
import { Listr, PRESET_TIMER } from "@aigne/listr2";
import { joinURL } from "ufo";
import { downloadAndExtract } from "../utils/download.js";
import { loadAIGNE } from "../utils/load-aigne.js";
import { runAgentWithAIGNE } from "../utils/run-with-aigne.js";
import { parseAgentInput, withAgentInputSchema } from "../utils/yargs.js";
import { serveMCPServerFromDir } from "./serve-mcp.js";
const NPM_PACKAGE_CACHE_TIME_MS = 1000 * 60 * 60 * 24; // 1 day
const builtinApps = [
    {
        name: "doc-smith",
        describe: "Generate and maintain project docs — powered by agents.",
        aliases: ["docsmith", "doc"],
    },
];
export function createAppCommands() {
    return builtinApps.map((app) => ({
        command: app.name,
        describe: app.describe,
        aliases: app.aliases,
        builder: async (yargs) => {
            const { aigne, dir, version, isCache } = await loadApplication({ name: app.name });
            yargs
                .option("model", {
                type: "string",
                description: "Model to use for the application, example: openai:gpt-4.1 or google:gemini-2.5-flash",
            })
                .command(serveMcpCommandModule({ name: app.name, dir }))
                .command(upgradeCommandModule({ name: app.name, dir, isLatest: !isCache, version }));
            if (aigne.cli.chat) {
                yargs.command({ ...agentCommandModule({ dir, agent: aigne.cli.chat }), command: "$0" });
            }
            for (const agent of aigne.cli?.agents ?? []) {
                yargs.command(agentCommandModule({ dir, agent }));
            }
            yargs.version(`${app.name} v${version}`).alias("version", "v");
            return yargs.demandCommand();
        },
        handler: () => { },
    }));
}
const serveMcpCommandModule = ({ name, dir, }) => ({
    command: "serve-mcp",
    describe: `Serve ${name} a MCP server (streamable http)`,
    builder: (yargs) => {
        return yargs
            .option("host", {
            describe: "Host to run the MCP server on, use 0.0.0.0 to publicly expose the server",
            type: "string",
            default: "localhost",
        })
            .option("port", {
            describe: "Port to run the MCP server on",
            type: "number",
        })
            .option("pathname", {
            describe: "Pathname to the service",
            type: "string",
            default: "/mcp",
        });
    },
    handler: async (options) => {
        await serveMCPServerFromDir({ ...options, dir });
    },
});
const upgradeCommandModule = ({ name, dir, isLatest, version, }) => ({
    command: "upgrade",
    describe: `Upgrade ${name} to the latest version`,
    handler: async () => {
        if (!isLatest) {
            const result = await loadApplication({ name, dir, forceUpgrade: true });
            if (version !== result.version) {
                console.log(`\n✅ Upgraded ${name} to version ${result.version}`);
                return;
            }
        }
        console.log(`\n✅ ${name} is already at the latest version (${version})`);
    },
});
const agentCommandModule = ({ dir, agent, }) => {
    return {
        command: agent.name,
        aliases: agent.alias || [],
        describe: agent.description || "",
        builder: async (yargs) => withAgentInputSchema(yargs, agent),
        handler: async (input) => {
            await invokeCLIAgentFromDir({ dir, agent: agent.name, input });
        },
    };
};
export async function invokeCLIAgentFromDir(options) {
    const aigne = await loadAIGNE({
        path: options.dir,
        modelOptions: { model: options.input.model },
    });
    try {
        const { chat, agents } = aigne.cli;
        const agent = chat && chat.name === options.agent ? chat : agents[options.agent];
        assert(agent, `Agent ${options.agent} not found in ${options.dir}`);
        const input = await parseAgentInput(options.input, agent);
        await runAgentWithAIGNE(aigne, agent, { input, chat: agent === chat });
    }
    finally {
        await aigne.shutdown();
    }
}
export async function loadApplication({ name, dir, forceUpgrade = false, }) {
    name = `@aigne/${name}`;
    dir ??= join(homedir(), ".aigne", "registry.npmjs.org", name);
    let check = forceUpgrade ? undefined : await isInstallationAvailable(dir);
    if (check?.available) {
        const aigne = await AIGNE.load(dir).catch((error) => {
            console.warn(`⚠️ Failed to load ${name}, trying to reinstall:`, error.message);
        });
        if (aigne) {
            return {
                aigne,
                dir,
                version: check.version,
                isCache: true,
            };
        }
        check = undefined;
    }
    const result = await new Listr([
        {
            title: `Fetching ${name} metadata`,
            task: async (ctx) => {
                const info = await getNpmTgzInfo(name);
                Object.assign(ctx, info);
            },
        },
        {
            title: `Downloading ${name}`,
            skip: (ctx) => ctx.version === check?.version,
            task: async (ctx) => {
                await rm(dir, { force: true, recursive: true });
                await mkdir(dir, { recursive: true });
                await downloadAndExtract(ctx.url, dir, { strip: 1 });
            },
        },
        {
            title: "Installing dependencies",
            task: async (_, task) => {
                await installDependencies(dir, {
                    log: (log) => {
                        const last = log.split("\n").findLast((i) => !!i);
                        if (last)
                            task.output = last;
                    },
                });
            },
        },
    ], {
        rendererOptions: {
            collapseSubtasks: false,
            showErrorMessage: false,
            timer: PRESET_TIMER,
        },
    }).run();
    return {
        aigne: await AIGNE.load(dir),
        dir,
        version: result.version,
    };
}
async function isInstallationAvailable(dir, { cacheTimeMs = NPM_PACKAGE_CACHE_TIME_MS } = {}) {
    const s = await stat(join(dir, "package.json")).catch(() => null);
    if (!s)
        return null;
    const version = safeParseJSON(await readFile(join(dir, "package.json"), "utf-8"))?.version;
    if (!version)
        return null;
    const installedAt = safeParseJSON(await readFile(join(dir, ".aigne-cli.json"), "utf-8").catch(() => "{}"))?.installedAt;
    if (!installedAt)
        return null;
    const now = Date.now();
    const available = installedAt ? now - installedAt < cacheTimeMs : false;
    return { version, available };
}
async function installDependencies(dir, { log } = {}) {
    await new Promise((resolve, reject) => {
        const child = spawn("corepack", ["npm", "install", "--omit", "dev", "--verbose"], {
            cwd: dir,
            stdio: "pipe",
            shell: process.platform === "win32",
        });
        child.stdout.on("data", (data) => {
            log?.(data.toString());
        });
        let stderr = "";
        child.stderr.on("data", (data) => {
            const str = data.toString();
            log?.(str);
            stderr += str;
        });
        child.on("error", (error) => reject(error));
        child.on("exit", (code) => {
            if (code === 0)
                resolve();
            else {
                console.error(stderr);
                reject(new Error(`npm install failed with code ${code}`));
            }
        });
    });
    await writeFile(join(dir, ".aigne-cli.json"), JSON.stringify({ installedAt: Date.now() }, null, 2));
}
async function getNpmTgzInfo(name) {
    const res = await fetch(joinURL("https://registry.npmjs.org", name));
    if (!res.ok)
        throw new Error(`Failed to fetch package info for ${name}: ${res.statusText}`);
    const data = await res.json();
    const latestVersion = data["dist-tags"].latest;
    const url = data.versions[latestVersion].dist.tarball;
    return {
        version: latestVersion,
        url,
    };
}
function safeParseJSON(raw) {
    try {
        return JSON.parse(raw);
    }
    catch { }
}
