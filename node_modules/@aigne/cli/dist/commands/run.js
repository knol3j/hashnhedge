import assert from "node:assert";
import { cp, mkdir, rm } from "node:fs/promises";
import { homedir } from "node:os";
import { isAbsolute, join, resolve } from "node:path";
import { logger } from "@aigne/core/utils/logger.js";
import { isNonNullable } from "@aigne/core/utils/type-utils.js";
import { Listr, PRESET_TIMER } from "@aigne/listr2";
import { input as inputInquirer, select as selectInquirer } from "@inquirer/prompts";
import { ListrInquirerPromptAdapter } from "@listr2/prompt-adapter-inquirer";
import { config } from "dotenv-flow";
import { isV1Package, toAIGNEPackage } from "../utils/agent-v1.js";
import { downloadAndExtract } from "../utils/download.js";
import { loadAIGNE } from "../utils/load-aigne.js";
import { createRunAIGNECommand, parseAgentInputByCommander, runAgentWithAIGNE, } from "../utils/run-with-aigne.js";
export function createRunCommand({ aigneFilePath, } = {}) {
    return {
        command: "run [path]",
        describe: "Run AIGNE from the specified agent",
        builder: (yargs) => {
            return createRunAIGNECommand(yargs)
                .positional("path", {
                describe: "Path to the agents directory or URL to aigne project",
                type: "string",
                default: ".",
                alias: ["url"],
            })
                .option("entry-agent", {
                describe: "Name of the agent to run (defaults to the first agent found)",
                type: "string",
            })
                .option("cache-dir", {
                describe: "Directory to download the package to (defaults to the ~/.aigne/xxx)",
                type: "string",
            })
                .option("aigne-hub-url", {
                describe: "Custom AIGNE Hub service URL. Used to fetch remote agent definitions or models. ",
                type: "string",
            })
                .strict(false);
        },
        handler: async (argv) => {
            const options = argv;
            const path = aigneFilePath || options.path;
            if (options.logLevel)
                logger.level = options.logLevel;
            const { cacheDir, dir } = prepareDirs(path, options);
            const originalLog = {};
            const { aigne, agent } = await new Listr([
                {
                    title: "Prepare environment",
                    task: (_, task) => {
                        if (cacheDir) {
                            return task.newListr([
                                {
                                    title: "Download package",
                                    task: () => downloadPackage(path, cacheDir),
                                },
                                {
                                    title: "Extract package",
                                    task: () => extractPackage(cacheDir, dir),
                                },
                            ]);
                        }
                    },
                },
                {
                    title: "Initialize AIGNE",
                    task: async (ctx, task) => {
                        // Load env files in the aigne directory
                        config({ path: dir, silent: true });
                        ctx.logs = [];
                        for (const method of ["debug", "log", "info", "warn", "error"]) {
                            originalLog[method] = console[method];
                            console[method] = (...args) => {
                                ctx.logs.push(...args);
                                task.output = args.join(" ");
                            };
                        }
                        const aigne = await loadAIGNE({
                            path: dir,
                            modelOptions: {
                                ...options,
                                inquirerPromptFn: (prompt) => {
                                    if (prompt.type === "input") {
                                        return task
                                            .prompt(ListrInquirerPromptAdapter)
                                            .run(inputInquirer, prompt)
                                            .then((res) => ({ [prompt.name]: res }));
                                    }
                                    return task
                                        .prompt(ListrInquirerPromptAdapter)
                                        .run(selectInquirer, prompt)
                                        .then((res) => ({ [prompt.name]: res }));
                                },
                            },
                        });
                        Object.assign(console, originalLog);
                        ctx.aigne = aigne;
                    },
                },
                {
                    task: (ctx) => {
                        const { aigne } = ctx;
                        assert(aigne);
                        let entryAgent;
                        if (options.entryAgent) {
                            entryAgent = aigne.agents[options.entryAgent];
                            if (!entryAgent) {
                                throw new Error(`\
Agent "${options.entryAgent}" not found in ${aigne.rootDir}

Available agents:
${aigne.agents.map((agent) => `  - ${agent.name}`).join("\n")}
`);
                            }
                        }
                        else {
                            entryAgent = aigne.agents[0];
                            if (!entryAgent)
                                throw new Error(`No any agent found in ${aigne.rootDir}`);
                        }
                        ctx.agent = entryAgent;
                    },
                },
            ], {
                rendererOptions: {
                    collapseSubtasks: false,
                    showErrorMessage: false,
                    timer: PRESET_TIMER,
                },
            })
                .run()
                .then((ctx) => {
                ctx.logs.forEach((log) => console.log(log));
                return ctx;
            });
            assert(aigne);
            assert(agent);
            const input = await parseAgentInputByCommander(agent, options);
            try {
                await runAgentWithAIGNE(aigne, agent, { ...options, input });
            }
            finally {
                await aigne.shutdown();
            }
        },
    };
}
async function downloadPackage(url, cacheDir) {
    await rm(cacheDir, { recursive: true, force: true });
    await mkdir(cacheDir, { recursive: true });
    await downloadAndExtract(url, cacheDir);
}
async function extractPackage(cacheDir, dir) {
    await mkdir(dir, { recursive: true });
    if (await isV1Package(cacheDir)) {
        await toAIGNEPackage(cacheDir, dir);
    }
    else {
        await cp(cacheDir, dir, { recursive: true, force: true });
    }
}
function prepareDirs(path, options) {
    let dir;
    let cacheDir;
    if (!path.startsWith("http")) {
        dir = isAbsolute(path) ? path : resolve(process.cwd(), path);
    }
    else if (options.cacheDir) {
        dir = isAbsolute(options.cacheDir)
            ? options.cacheDir
            : resolve(process.cwd(), options.cacheDir);
        cacheDir = join(dir, ".download");
    }
    else {
        dir = getLocalPackagePathFromUrl(path);
        cacheDir = getLocalPackagePathFromUrl(path, { subdir: ".download" });
    }
    return { cacheDir, dir };
}
function getLocalPackagePathFromUrl(url, { subdir } = {}) {
    const root = [homedir(), ".aigne", subdir].filter(isNonNullable);
    const u = new URL(url);
    return join(...root, u.hostname, u.pathname);
}
