import { ChatModel, } from "@aigne/core";
import { parseJSON } from "@aigne/core/utils/json-schema.js";
import { mergeUsage } from "@aigne/core/utils/model-utils.js";
import { getJsonToolInputPrompt } from "@aigne/core/utils/prompts.js";
import { agentResponseStreamToObject } from "@aigne/core/utils/stream-utils.js";
import { checkArguments, isNonNullable, } from "@aigne/core/utils/type-utils.js";
import { BedrockRuntimeClient, ConverseCommand, ConverseStreamCommand, } from "@aws-sdk/client-bedrock-runtime";
import { v7 } from "uuid";
import { z } from "zod";
/**
 * @hidden
 */
export function extractLastJsonObject(text) {
    return text.replace(/<thinking>[\s\S]*?<\/thinking>/g, "").trim();
}
const BEDROCK_DEFAULT_CHAT_MODEL = "us.amazon.nova-lite-v1:0";
/**
 * @hidden
 */
export const bedrockChatModelOptionsSchema = z.object({
    region: z.string().optional(),
    model: z.string().optional(),
    modelOptions: z
        .object({
        model: z.string().optional(),
        temperature: z.number().optional(),
        topP: z.number().optional(),
        frequencyPenalty: z.number().optional(),
        presencePenalty: z.number().optional(),
        parallelToolCalls: z.boolean().optional().default(true),
    })
        .optional(),
});
export class BedrockChatModel extends ChatModel {
    options;
    constructor(options) {
        if (options)
            checkArguments("BedrockChatModel", bedrockChatModelOptionsSchema, options);
        super();
        this.options = options;
    }
    /**
     * @hidden
     */
    _client;
    get client() {
        const { accessKeyId, secretAccessKey, region } = this.credential;
        if (!accessKeyId || !secretAccessKey)
            throw new Error(`\
${this.name} requires access key id and secret. Please provide it via \`options.accessKeyId\` and \`options.secretAccessKey\`, \
or set the \`AWS_ACCESS_KEY_ID\` and \`AWS_SECRET_ACCESS_KEY\` environment variables`);
        this._client ??= new BedrockRuntimeClient({
            region: region,
            credentials: { accessKeyId, secretAccessKey },
            ...this.options?.clientOptions,
        });
        return this._client;
    }
    get modelOptions() {
        return this.options?.modelOptions;
    }
    get credential() {
        const accessKeyId = this.options?.accessKeyId || process.env["AWS_ACCESS_KEY_ID"];
        const secretAccessKey = this.options?.secretAccessKey || process.env["AWS_SECRET_ACCESS_KEY"];
        const region = this.options?.region || process.env["AWS_REGION"];
        return {
            accessKeyId,
            secretAccessKey,
            region,
            apiKey: secretAccessKey,
            model: this.modelOptions?.model ?? BEDROCK_DEFAULT_CHAT_MODEL,
        };
    }
    /**
     * Process the input using Bedrock's chat model
     * @param input - The input to process
     * @returns The processed output from the model
     */
    process(input) {
        return this._process(input);
    }
    async _process(input) {
        const modelId = input.modelOptions?.model ?? this.credential.model;
        const { messages, system } = getRunMessages(input);
        const toolConfig = convertTools(input);
        const body = {
            modelId,
            messages,
            system,
            toolConfig,
            inferenceConfig: {
                temperature: input.modelOptions?.temperature ?? this.modelOptions?.temperature,
                topP: input.modelOptions?.topP ?? this.modelOptions?.topP,
            },
        };
        const command = new ConverseStreamCommand(body);
        const response = await this.client.send(command);
        const jsonMode = input.responseFormat?.type === "json_schema";
        if (!jsonMode) {
            return this.extractResultFromStream(response.stream, modelId, true);
        }
        const result = await this.extractResultFromStream(response.stream, modelId, false);
        if (!result.toolCalls?.length && jsonMode && result.text) {
            const output = await this.requestStructuredOutput(body, input.responseFormat);
            return { ...output, usage: mergeUsage(result.usage, output.usage) };
        }
        return result;
    }
    async extractResultFromStream(stream, modelId, streaming) {
        if (!stream)
            throw new Error("Unable to get AI model response.");
        const result = new ReadableStream({
            start: async (controller) => {
                try {
                    controller.enqueue({ delta: { json: { model: modelId } } });
                    const toolCalls = [];
                    let usage;
                    for await (const chunk of stream) {
                        if (chunk.contentBlockStart?.start?.toolUse) {
                            const toolUse = chunk.contentBlockStart.start.toolUse;
                            if (!toolUse.name)
                                throw new Error("Tool use is invalid");
                            if (chunk.contentBlockStart.contentBlockIndex === undefined)
                                throw new Error("Tool use content block index is required");
                            toolCalls[chunk.contentBlockStart.contentBlockIndex] = {
                                type: "function",
                                id: toolUse.toolUseId || v7(),
                                function: {
                                    name: toolUse.name,
                                    arguments: {},
                                },
                                args: "",
                            };
                        }
                        if (chunk.contentBlockDelta) {
                            const block = chunk.contentBlockDelta;
                            const delta = block.delta;
                            if (delta?.text) {
                                controller.enqueue({ delta: { text: { text: delta.text } } });
                            }
                            if (delta?.toolUse) {
                                if (block.contentBlockIndex === undefined)
                                    throw new Error("Content block index is required");
                                const call = toolCalls[block.contentBlockIndex];
                                if (!call)
                                    throw new Error("Tool call not found");
                                call.args += delta.toolUse.input;
                            }
                        }
                        if (chunk.metadata?.usage) {
                            const { inputTokens = 0, outputTokens = 0 } = chunk.metadata.usage;
                            usage = { inputTokens, outputTokens };
                        }
                    }
                    if (toolCalls.length) {
                        controller.enqueue({
                            delta: {
                                json: {
                                    toolCalls: toolCalls
                                        .map(({ args, ...c }) => ({
                                        ...c,
                                        function: { ...c.function, arguments: parseJSON(args) },
                                    }))
                                        .filter(isNonNullable),
                                },
                            },
                        });
                    }
                    controller.enqueue({ delta: { json: { usage } } });
                    controller.close();
                }
                catch (error) {
                    controller.error(error);
                }
            },
        });
        return streaming ? result : await agentResponseStreamToObject(result);
    }
    async requestStructuredOutput(body, responseFormat) {
        if (responseFormat?.type !== "json_schema") {
            throw new Error("Expected json_schema response format");
        }
        const system = [
            ...(body.system ?? []),
            {
                text: `Use the generate_json tool to generate a json result. ${getJsonToolInputPrompt(responseFormat.jsonSchema.schema)}`,
            },
        ];
        const toolConfig = {
            tools: [
                {
                    toolSpec: {
                        name: "generate_json",
                        description: "Generate a json result by given context",
                        inputSchema: { json: responseFormat.jsonSchema.schema },
                    },
                },
            ],
            toolChoice: { tool: { name: "generate_json" } },
        };
        const command = new ConverseCommand({ ...body, system, toolConfig });
        const response = await this.client.send(command);
        const jsonTool = response.output?.message?.content?.find((i) => i.toolUse?.name === "generate_json");
        if (!jsonTool)
            throw new Error("Json tool not found");
        return {
            json: jsonTool.toolUse?.input,
            model: body.modelId,
            usage: response.usage,
        };
    }
}
const getRunMessages = ({ messages: msgs, }) => {
    const system = [];
    const messages = [];
    for (const msg of msgs) {
        if (msg.role === "system") {
            if (typeof msg.content !== "string")
                throw new Error("System message must have content");
            system.push({ text: msg.content });
        }
        else if (msg.role === "tool") {
            if (!msg.toolCallId)
                throw new Error("Tool message must have toolCallId");
            if (typeof msg.content !== "string")
                throw new Error("Tool message must have string content");
            if (messages.at(-1)?.role === "user") {
                messages.at(-1)?.content?.push({
                    toolResult: { toolUseId: msg.toolCallId, content: [{ json: parseJSON(msg.content) }] },
                });
            }
            else {
                messages.push({
                    role: "user",
                    content: [
                        {
                            toolResult: {
                                toolUseId: msg.toolCallId,
                                content: [{ json: parseJSON(msg.content) }],
                            },
                        },
                    ],
                });
            }
        }
        else if (msg.role === "user") {
            if (!msg.content)
                throw new Error("User message must have content");
            messages.push({ role: "user", content: convertContent(msg.content) });
        }
        else if (msg.role === "agent") {
            if (msg.toolCalls?.length) {
                messages.push({
                    role: "assistant",
                    content: msg.toolCalls.map((i) => ({
                        toolUse: {
                            toolUseId: i.id,
                            name: i.function.name,
                            input: i.function.arguments,
                        },
                    })),
                });
            }
            else if (msg.content) {
                messages.push({ role: "assistant", content: convertContent(msg.content) });
            }
            else {
                throw new Error("Agent message must have content or toolCalls");
            }
        }
    }
    if (messages.at(0)?.role !== "user") {
        messages.unshift({ role: "user", content: [{ text: "." }] });
    }
    return { messages, system };
};
function convertContent(content) {
    if (typeof content === "string")
        return [{ text: content }];
    if (Array.isArray(content)) {
        const blocks = [];
        for (const item of content) {
            if (item.type === "text")
                blocks.push({ text: item.text });
        }
        return blocks;
    }
    throw new Error("Invalid chat message content");
}
function convertTools({ tools, toolChoice }) {
    if (!tools?.length || toolChoice === "none")
        return undefined;
    let choice;
    if (typeof toolChoice === "object" && "type" in toolChoice && toolChoice.type === "function") {
        choice = { tool: { name: toolChoice.function.name } };
    }
    else if (toolChoice === "required") {
        choice = { any: {} };
    }
    else if (toolChoice === "auto") {
        choice = { auto: {} };
    }
    return {
        tools: tools.map((i) => {
            const parameters = i.function.parameters;
            if (Object.keys(parameters).length === 0) {
                parameters.type = "object";
            }
            return {
                toolSpec: {
                    name: i.function.name,
                    description: i.function.description,
                    inputSchema: { json: parameters },
                },
            };
        }),
        toolChoice: choice,
    };
}
