import { type ZodType, z } from "zod";
export type PromiseOrValue<T> = T | Promise<T>;
export type Nullish<T> = T | null | undefined | void;
export type OmitPropertiesFromArrayFirstElement<T extends unknown[], K extends string | number | symbol> = T extends [infer U, ...infer Rest] ? [Omit<U, K>, ...Rest] : never;
export type XOr<T, K extends keyof T, O extends keyof T> = (Omit<T, O> & {
    [key in O]?: undefined;
}) | (Omit<T, K> & {
    [key in K]?: undefined;
});
export declare function isNil(value: unknown): value is null | undefined;
export declare function isRecord<T>(value: unknown): value is Record<string, T>;
export declare function isEmpty(obj: unknown): boolean;
export declare function isNonNullable<T>(value: T): value is NonNullable<T>;
export declare function isNotEmpty<T>(arr: T[]): arr is [T, ...T[]];
export declare function duplicates<T>(arr: T[], key?: (item: T) => unknown): T[];
export declare function remove<T>(arr: T[], remove: T[] | ((item: T) => boolean)): T[];
export declare function unique<T>(arr: T[], key?: (item: T) => unknown): T[];
export declare function pick<T extends object, K extends keyof T>(obj: T, ...keys: (K | K[])[]): Pick<T, K>;
export declare function omit<T extends object, K extends keyof T>(obj: T, ...keys: (K | K[])[]): Omit<T, K>;
export declare function omitDeep<T, K>(obj: T, ...keys: (K | K[])[]): unknown;
export declare function omitBy<T extends object, K extends keyof T>(obj: T, predicate: (value: T[K], key: K) => boolean): Partial<T>;
export declare function flat<T>(...value: (T | T[])[]): NonNullable<T>[];
export declare function createAccessorArray<T>(array: T[], accessor: (array: T[], name: string) => T | undefined): T[] & {
    [key: string]: T;
};
export declare function checkArguments<T extends ZodType>(prefix: string, schema: T, args: unknown): z.infer<T>;
export declare function tryOrThrow<P extends PromiseOrValue<unknown>>(fn: () => P, error: string | Error | ((error: Error) => Error)): P;
export declare function tryOrThrow<P extends PromiseOrValue<unknown>>(fn: () => P, error?: Nullish<string | Error | ((error: Error) => Nullish<Error>)>): P | undefined;
