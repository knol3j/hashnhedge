import type { AIGNEObserver } from "@aigne/observability-api";
import type { Span } from "@opentelemetry/api";
import { Emitter } from "strict-event-emitter";
import { type Agent, type AgentHooks, type AgentInvokeOptions, type AgentProcessAsyncGenerator, type AgentResponse, type AgentResponseStream, type Message } from "../agents/agent.js";
import type { ChatModel } from "../agents/chat-model.js";
import type { ImageModel } from "../agents/image-model.js";
import { UserAgent } from "../agents/user-agent.js";
import type { Memory } from "../memory/memory.js";
import { type OmitPropertiesFromArrayFirstElement } from "../utils/type-utils.js";
import type { Args, Listener, TypedEventEmitter } from "../utils/typed-event-emitter.js";
import { type MessagePayload, MessageQueue, type MessageQueueListener, type Unsubscribe } from "./message-queue.js";
import { type ContextLimits, type ContextUsage } from "./usage.js";
/**
 * @hidden
 */
export interface AgentEvent {
    parentContextId?: string;
    contextId: string;
    timestamp: number;
    agent: Agent;
}
/**
 * @hidden
 */
export interface ContextEventMap {
    agentStarted: [AgentEvent & {
        input: Message;
        taskTitle?: string;
    }];
    agentSucceed: [AgentEvent & {
        output: Message;
    }];
    agentFailed: [AgentEvent & {
        error: Error;
    }];
}
/**
 * @hidden
 */
export type ContextEmitEventMap = {
    [K in keyof ContextEventMap]: OmitPropertiesFromArrayFirstElement<ContextEventMap[K], "contextId" | "parentContextId" | "timestamp">;
};
/**
 * @hidden
 */
export interface InvokeOptions<U extends UserContext = UserContext> extends Partial<Omit<AgentInvokeOptions<U>, "context">> {
    returnActiveAgent?: boolean;
    returnProgressChunks?: boolean;
    returnMetadata?: boolean;
    disableTransfer?: boolean;
    sourceAgent?: Agent;
    /**
     * Whether to create a new context for this invocation.
     * If false, the invocation will use the current context.
     *
     * @default true
     */
    newContext?: boolean;
    userContext?: U;
    memories?: Pick<Memory, "content">[];
}
/**
 * @hidden
 */
export interface UserContext extends Record<string, unknown> {
    userId?: string;
    sessionId?: string;
}
/**
 * @hidden
 */
export interface Context<U extends UserContext = UserContext> extends TypedEventEmitter<ContextEventMap, ContextEmitEventMap> {
    id: string;
    parentId?: string;
    rootId: string;
    model?: ChatModel;
    imageModel?: ImageModel;
    skills?: Agent[];
    agents: Agent[];
    observer?: AIGNEObserver;
    span?: Span;
    usage: ContextUsage;
    limits?: ContextLimits;
    status?: "normal" | "timeout";
    userContext: U;
    hooks?: AgentHooks[];
    memories: Pick<Memory, "content">[];
    /**
     * Create a user agent to consistently invoke an agent
     * @param agent Agent to invoke
     * @returns User agent
     */
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>): UserAgent<I, O>;
    /**
     * Invoke an agent with a message and return the output and the active agent
     * @param agent Agent to invoke
     * @param message Message to pass to the agent
     * @param options.returnActiveAgent return the active agent
     * @param options.streaming return a stream of the output
     * @returns the output of the agent and the final active agent
     */
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, message: I & Message, options: InvokeOptions & {
        returnActiveAgent: true;
        streaming?: false;
    }): Promise<[O, Agent]>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, message: I & Message, options: InvokeOptions & {
        returnActiveAgent: true;
        streaming: true;
    }): Promise<[AgentResponseStream<O>, Promise<Agent>]>;
    /**
     * Invoke an agent with a message
     * @param agent Agent to invoke
     * @param message Message to pass to the agent
     * @returns the output of the agent
     */
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, message: I & Message, options?: InvokeOptions & {
        streaming?: false;
    }): Promise<O>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, message: I & Message, options: InvokeOptions & {
        streaming: true;
    }): Promise<AgentResponseStream<O>>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, message?: I & Message, options?: InvokeOptions): UserAgent<I, O> | Promise<AgentResponse<O> | [AgentResponse<O>, Agent]>;
    /**
     * Publish a message to a topic, the aigne will invoke the listeners of the topic
     * @param topic topic name, or an array of topic names
     * @param payload message to publish
     */
    publish(topic: string | string[], payload: Omit<MessagePayload, "context"> | Message, options?: InvokeOptions): void;
    subscribe(topic: string | string[], listener?: undefined): Promise<MessagePayload>;
    subscribe(topic: string | string[], listener: MessageQueueListener): Unsubscribe;
    subscribe(topic: string | string[], listener?: MessageQueueListener): Unsubscribe | Promise<MessagePayload>;
    subscribe(topic: string | string[], listener?: MessageQueueListener): Unsubscribe | Promise<MessagePayload>;
    unsubscribe(topic: string | string[], listener: MessageQueueListener): void;
    /**
     * Create a child context with the same configuration as the parent context.
     * If `reset` is true, the child context will have a new state (such as: usage).
     *
     * @param options
     * @param options.reset create a new context with initial state (such as: usage)
     * @returns new context
     */
    newContext(options?: {
        reset?: boolean;
    }): Context;
}
/**
 * @hidden
 */
export declare class AIGNEContext implements Context {
    constructor(parent?: ConstructorParameters<typeof AIGNEContextShared>[0], { reset }?: {
        reset?: boolean;
    });
    id: string;
    parentId?: string;
    rootId: string;
    span?: Span;
    readonly internal: AIGNEContextShared;
    get messageQueue(): MessageQueue;
    get model(): ChatModel | undefined;
    get imageModel(): ImageModel<import("../agents/image-model.js").ImageModelInput, import("../agents/image-model.js").ImageModelOutput> | undefined;
    get skills(): Agent<any, any>[] | undefined;
    get agents(): Agent<any, any>[];
    get observer(): AIGNEObserver | undefined;
    get limits(): ContextLimits | undefined;
    get status(): "normal" | "timeout";
    get usage(): ContextUsage;
    get userContext(): Context["userContext"];
    set userContext(userContext: Context["userContext"]);
    get memories(): Context["memories"];
    set memories(memories: Context["memories"]);
    get hooks(): AgentHooks[];
    set hooks(hooks: AgentHooks[]);
    newContext({ reset }?: {
        reset?: boolean;
    }): AIGNEContext;
    invoke: Context["invoke"];
    private onInvocationResult;
    private processOptions;
    publish: Context["publish"];
    subscribe: Context["subscribe"];
    unsubscribe: Context["unsubscribe"];
    emit<K extends keyof ContextEmitEventMap>(eventName: K, ...args: Args<K, ContextEmitEventMap>): boolean;
    private trace;
    on<K extends keyof ContextEventMap>(eventName: K, listener: Listener<K, ContextEventMap>): this;
    once<K extends keyof ContextEventMap>(eventName: K, listener: Listener<K, ContextEventMap>): this;
    off<K extends keyof ContextEventMap>(eventName: K, listener: Listener<K, ContextEventMap>): this;
}
declare class AIGNEContextShared {
    private readonly parent?;
    constructor(parent?: (Pick<Context, "model" | "imageModel" | "agents" | "skills" | "limits" | "observer"> & {
        messageQueue?: MessageQueue;
        events?: Emitter<any>;
    }) | undefined);
    readonly messageQueue: MessageQueue;
    readonly events: Emitter<any>;
    get model(): ChatModel | undefined;
    get imageModel(): ImageModel<import("../agents/image-model.js").ImageModelInput, import("../agents/image-model.js").ImageModelOutput> | undefined;
    get skills(): Agent<any, any>[] | undefined;
    get agents(): Agent<any, any>[];
    get observer(): AIGNEObserver | undefined;
    get limits(): ContextLimits | undefined;
    usage: ContextUsage;
    userContext: Context["userContext"];
    memories: Context["memories"];
    hooks: AgentHooks[];
    private abortController;
    private timer?;
    private initTimeout;
    get status(): "normal" | "timeout";
    invoke<I extends Message, O extends Message>(agent: Agent<I, O>, input: I & Message, context: Context, options?: InvokeOptions): AgentProcessAsyncGenerator<O & {
        __activeAgent__: Agent;
    }>;
    private invokeAgent;
}
export {};
