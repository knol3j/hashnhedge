"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageQueue = exports.UserOutputTopic = exports.UserInputTopic = void 0;
exports.toMessagePayload = toMessagePayload;
const strict_event_emitter_1 = require("strict-event-emitter");
const zod_1 = require("zod");
const type_utils_js_1 = require("../utils/type-utils.js");
/**
 * @hidden
 */
exports.UserInputTopic = "UserInputTopic";
/**
 * @hidden
 */
exports.UserOutputTopic = "UserOutputTopic";
function isMessagePayload(payload) {
    return (!(0, type_utils_js_1.isNil)(payload) &&
        typeof payload === "object" &&
        "role" in payload &&
        typeof payload.role === "string" &&
        ["user", "agent"].includes(payload.role) &&
        "message" in payload &&
        !(0, type_utils_js_1.isNil)(payload.message));
}
/**
 * @hidden
 */
function toMessagePayload(payload, options) {
    if (isMessagePayload(payload)) {
        return { ...payload, ...options };
    }
    return {
        role: options?.role || "user",
        source: options?.source,
        message: payload,
    };
}
/**
 * @hidden
 */
class MessageQueue {
    events = new strict_event_emitter_1.Emitter();
    publish(topic, payload) {
        (0, type_utils_js_1.checkArguments)("MessageQueue.publish", publishArgsSchema, {
            topic,
            payload,
        });
        for (const t of (0, type_utils_js_1.flat)(topic)) {
            this.events.emit(t, payload);
        }
    }
    error(error) {
        this.events.emit("error", error);
    }
    subscribe(topic, listener) {
        (0, type_utils_js_1.checkArguments)("MessageQueue.subscribe", subscribeArgsSchema, {
            topic,
            listener,
        });
        if (!listener) {
            return new Promise((resolve, reject) => {
                const unsubscribe1 = once(this.events, topic, (message) => {
                    unsubscribe2();
                    resolve(message);
                });
                const unsubscribe2 = once(this.events, "error", (error) => {
                    unsubscribe1();
                    reject(error);
                });
            });
        }
        return on(this.events, topic, listener);
    }
    unsubscribe(topic, listener) {
        (0, type_utils_js_1.checkArguments)("MessageQueue.unsubscribe", unsubscribeArgsSchema, {
            topic,
            listener,
        });
        for (const t of (0, type_utils_js_1.flat)(topic)) {
            this.events.off(t, listener);
        }
    }
}
exports.MessageQueue = MessageQueue;
function on(events, event, listener) {
    (0, type_utils_js_1.flat)(event).forEach((e) => events.on(e, listener));
    return () => (0, type_utils_js_1.flat)(event).forEach((e) => events.off(e, listener));
}
function once(events, event, listener) {
    (0, type_utils_js_1.flat)(event).forEach((e) => events.once(e, listener));
    return () => (0, type_utils_js_1.flat)(event).forEach((e) => events.off(e, listener));
}
const subscribeArgsSchema = zod_1.z.object({
    topic: zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]),
    listener: zod_1.z.custom().optional(),
});
const unsubscribeArgsSchema = zod_1.z.object({
    topic: zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]),
    listener: zod_1.z.custom(),
});
const publishArgsSchema = zod_1.z.object({
    topic: zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]),
    payload: zod_1.z.object({
        role: zod_1.z.union([zod_1.z.literal("user"), zod_1.z.literal("agent")]),
        source: zod_1.z.string().optional(),
        message: zod_1.z.union([zod_1.z.string(), zod_1.z.record(zod_1.z.string(), zod_1.z.unknown())]),
        context: zod_1.z.any(),
    }),
});
