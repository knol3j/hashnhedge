"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIGNEContext = void 0;
const api_1 = require("@opentelemetry/api");
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const strict_event_emitter_1 = require("strict-event-emitter");
const uuid_1 = require("uuid");
const zod_1 = require("zod");
const agent_js_1 = require("../agents/agent.js");
const types_js_1 = require("../agents/types.js");
const user_agent_js_1 = require("../agents/user-agent.js");
const event_stream_js_1 = require("../utils/event-stream.js");
const logger_js_1 = require("../utils/logger.js");
const promise_js_1 = require("../utils/promise.js");
const stream_utils_js_1 = require("../utils/stream-utils.js");
const type_utils_js_1 = require("../utils/type-utils.js");
const message_queue_js_1 = require("./message-queue.js");
const usage_js_1 = require("./usage.js");
/**
 * @hidden
 */
class AIGNEContext {
    constructor(parent, { reset } = {}) {
        const tracer = parent?.observer?.tracer;
        if (parent instanceof AIGNEContext && !reset) {
            this.internal = parent.internal;
            this.parentId = parent.id;
            this.rootId = parent.rootId;
            if (parent.span) {
                const parentContext = api_1.trace.setSpan(api_1.context.active(), parent.span);
                this.span = tracer?.startSpan("childAIGNEContext", undefined, parentContext);
            }
            else {
                if (parent.observer && !process.env.AIGNE_OBSERVABILITY_DISABLED) {
                    throw new Error("parent span is not set");
                }
            }
        }
        else {
            this.span = tracer?.startSpan("AIGNEContext");
            this.internal = new AIGNEContextShared(parent instanceof AIGNEContext ? parent.internal : parent);
            // 修改了 rootId 是否会之前的有影响？，之前为 this.id
            this.rootId = this.span?.spanContext?.().traceId ?? (0, uuid_1.v7)();
        }
        this.id = this.span?.spanContext()?.spanId ?? (0, uuid_1.v7)();
    }
    id;
    parentId;
    rootId;
    span;
    internal;
    get messageQueue() {
        return this.internal.messageQueue;
    }
    get model() {
        return this.internal.model;
    }
    get imageModel() {
        return this.internal.imageModel;
    }
    get skills() {
        return this.internal.skills;
    }
    get agents() {
        return this.internal.agents;
    }
    get observer() {
        return this.internal.observer;
    }
    get limits() {
        return this.internal.limits;
    }
    get status() {
        return this.internal.status;
    }
    get usage() {
        return this.internal.usage;
    }
    get userContext() {
        return this.internal.userContext;
    }
    set userContext(userContext) {
        this.internal.userContext = userContext;
    }
    get memories() {
        return this.internal.memories;
    }
    set memories(memories) {
        this.internal.memories = memories;
    }
    get hooks() {
        return this.internal.hooks;
    }
    set hooks(hooks) {
        this.internal.hooks = hooks;
    }
    newContext({ reset } = {}) {
        return new AIGNEContext(this, { reset });
    }
    invoke = ((agent, message, options) => {
        (0, type_utils_js_1.checkArguments)("AIGNEContext.invoke", aigneContextInvokeArgsSchema, {
            agent,
            message,
            options,
        });
        this.processOptions(options);
        if ((0, type_utils_js_1.isNil)(message)) {
            return user_agent_js_1.UserAgent.from({
                context: this,
                activeAgent: agent,
            });
        }
        const newContext = options?.newContext === false ? this : this.newContext();
        return Promise.resolve(newContext.internal.invoke(agent, message, newContext, options)).then(async (response) => {
            if (!options?.streaming) {
                let { __activeAgent__: activeAgent, ...output } = await (0, stream_utils_js_1.agentResponseStreamToObject)(response);
                output = await this.onInvocationResult(output, options);
                if (options?.returnActiveAgent) {
                    return [output, activeAgent];
                }
                return output;
            }
            const activeAgentPromise = (0, promise_js_1.promiseWithResolvers)();
            const stream = (0, stream_utils_js_1.onAgentResponseStreamEnd)((0, stream_utils_js_1.asyncGeneratorToReadableStream)(response), {
                onChunk(chunk) {
                    if ((0, agent_js_1.isAgentResponseDelta)(chunk) && chunk.delta.json) {
                        return {
                            ...chunk,
                            delta: {
                                ...chunk.delta,
                                json: (0, type_utils_js_1.omit)(chunk.delta.json, "__activeAgent__"),
                            },
                        };
                    }
                },
                onResult: async (output) => {
                    activeAgentPromise.resolve(output.__activeAgent__);
                    return await this.onInvocationResult(output, options);
                },
            });
            const finalStream = !options.returnProgressChunks
                ? stream
                : (0, stream_utils_js_1.mergeReadableStreams)(stream, new event_stream_js_1.AgentResponseProgressStream(newContext));
            if (options.returnActiveAgent) {
                return [finalStream, activeAgentPromise.promise];
            }
            return finalStream;
        });
    });
    async onInvocationResult(output, options) {
        if (!options?.returnMetadata) {
            return output;
        }
        return {
            ...output,
            $meta: {
                ...output.$meta,
                usage: this.usage,
            },
        };
    }
    processOptions(options) {
        if (options?.userContext) {
            Object.assign(this.userContext, options.userContext);
            options.userContext = undefined;
        }
        if (options?.memories?.length) {
            this.memories.push(...options.memories);
            options.memories = undefined;
        }
        if (options?.hooks) {
            this.hooks.push(...(0, type_utils_js_1.flat)(options.hooks));
            options.hooks = undefined;
        }
    }
    publish = ((topic, payload, options) => {
        this.processOptions(options);
        const newContext = options?.newContext === false ? this : this.newContext();
        return this.internal.messageQueue.publish(topic, {
            ...(0, message_queue_js_1.toMessagePayload)(payload),
            context: newContext,
        });
    });
    subscribe = ((...args) => {
        return this.internal.messageQueue.subscribe(...args);
    });
    unsubscribe = ((...args) => {
        return this.internal.messageQueue.unsubscribe(...args);
    });
    emit(eventName, ...args) {
        const b = {
            ...args[0],
            contextId: this.id,
            parentContextId: this.parentId,
            timestamp: Date.now(),
        };
        const newArgs = [b, ...args.slice(1)];
        this.trace(eventName, args, b);
        return this.internal.events.emit(eventName, ...newArgs);
    }
    async trace(eventName, args, b) {
        const span = this.span;
        if (!span)
            return;
        try {
            switch (eventName) {
                case "agentStarted": {
                    const { agent, input } = args[0];
                    span.updateName(agent.name);
                    span.setAttribute("custom.trace_id", this.rootId);
                    span.setAttribute("custom.span_id", this.id);
                    if (this.parentId) {
                        span.setAttribute("custom.parent_id", this.parentId);
                    }
                    span.setAttribute("custom.started_at", b.timestamp);
                    span.setAttribute("input", JSON.stringify(input));
                    span.setAttribute("agentTag", agent.tag ?? "UnknownAgent");
                    try {
                        span.setAttribute("userContext", JSON.stringify(this.userContext));
                    }
                    catch (_e) {
                        logger_js_1.logger.error("parse userContext error", _e.message);
                        span.setAttribute("userContext", JSON.stringify({}));
                    }
                    try {
                        span.setAttribute("memories", JSON.stringify(this.memories));
                    }
                    catch (_e) {
                        logger_js_1.logger.error("parse memories error", _e.message);
                        span.setAttribute("memories", JSON.stringify([]));
                    }
                    await this.observer?.flush(span);
                    break;
                }
                case "agentSucceed": {
                    const { output } = args[0];
                    try {
                        span.setAttribute("output", JSON.stringify(output));
                    }
                    catch (_e) {
                        logger_js_1.logger.error("parse output error", _e.message);
                        span.setAttribute("output", JSON.stringify({}));
                    }
                    span.setStatus({ code: api_1.SpanStatusCode.OK });
                    span.end();
                    break;
                }
                case "agentFailed": {
                    const { error } = args[0];
                    span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: error.message });
                    span.end();
                    break;
                }
            }
        }
        catch (err) {
            logger_js_1.logger.error("AIGNEContext.trace observer error", { eventName, error: err });
        }
    }
    on(eventName, listener) {
        this.internal.events.on(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        this.internal.events.once(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        this.internal.events.off(eventName, listener);
        return this;
    }
}
exports.AIGNEContext = AIGNEContext;
class AIGNEContextShared {
    parent;
    constructor(parent) {
        this.parent = parent;
        this.messageQueue = this.parent?.messageQueue ?? new message_queue_js_1.MessageQueue();
        this.events = this.parent?.events ?? new strict_event_emitter_1.Emitter();
    }
    messageQueue;
    events;
    get model() {
        return this.parent?.model;
    }
    get imageModel() {
        return this.parent?.imageModel;
    }
    get skills() {
        return this.parent?.skills;
    }
    get agents() {
        return this.parent?.agents ?? [];
    }
    get observer() {
        return this.parent?.observer;
    }
    get limits() {
        return this.parent?.limits;
    }
    usage = (0, usage_js_1.newEmptyContextUsage)();
    userContext = {};
    memories = [];
    hooks = [];
    abortController = new AbortController();
    timer;
    initTimeout() {
        if (this.timer)
            return;
        const timeout = this.limits?.timeout;
        if (timeout) {
            this.timer = setTimeout(() => {
                this.abortController.abort();
            }, timeout);
        }
    }
    get status() {
        return this.abortController.signal.aborted ? "timeout" : "normal";
    }
    invoke(agent, input, context, options) {
        this.initTimeout();
        return withAbortSignal(this.abortController.signal, new Error("AIGNEContext is timeout"), () => this.invokeAgent(agent, input, context, options));
    }
    async *invokeAgent(agent, input, context, options = {}) {
        const startedAt = Date.now();
        try {
            let activeAgent = agent;
            for (;;) {
                const result = {};
                if (options?.sourceAgent && activeAgent !== options.sourceAgent) {
                    for (const { onHandoff } of (0, type_utils_js_1.flat)(options.hooks, options.sourceAgent.hooks)) {
                        if (!onHandoff)
                            continue;
                        await (typeof onHandoff === "function"
                            ? onHandoff({
                                context,
                                source: options.sourceAgent,
                                target: activeAgent,
                                input,
                            })
                            : context.invoke(onHandoff, {
                                source: options.sourceAgent,
                                target: activeAgent,
                                input,
                            }));
                    }
                }
                const stream = await activeAgent.invoke(input, {
                    hooks: options.hooks,
                    context,
                    streaming: true,
                });
                for await (const value of stream) {
                    if ((0, agent_js_1.isAgentResponseDelta)(value)) {
                        if (value.delta.json) {
                            value.delta.json = omitExistsProperties(result, value.delta.json);
                            Object.assign(result, value.delta.json);
                        }
                        delete value.delta.json?.[types_js_1.transferAgentOutputKey];
                    }
                    if ((0, agent_js_1.isEmptyChunk)(value))
                        continue;
                    yield value;
                }
                if (!options?.disableTransfer) {
                    const transferToAgent = (0, types_js_1.isTransferAgentOutput)(result)
                        ? result[types_js_1.transferAgentOutputKey].agent
                        : undefined;
                    if (transferToAgent) {
                        activeAgent = transferToAgent;
                        continue;
                    }
                }
                break;
            }
            yield {
                delta: {
                    json: { __activeAgent__: activeAgent },
                },
            };
        }
        finally {
            const endedAt = Date.now();
            const duration = endedAt - startedAt;
            this.usage.duration += duration;
        }
    }
}
function omitExistsProperties(result, { ...delta }) {
    for (const [key, val] of Object.entries(delta)) {
        if ((0, fast_deep_equal_1.default)(result[key], val))
            delete delta[key];
    }
    return (0, type_utils_js_1.isEmpty)(delta) ? undefined : delta;
}
async function* withAbortSignal(signal, error, fn) {
    const iterator = fn();
    const timeoutPromise = (0, promise_js_1.promiseWithResolvers)();
    const listener = () => {
        timeoutPromise.reject(error);
    };
    signal.addEventListener("abort", listener);
    try {
        for (;;) {
            const next = await Promise.race([iterator.next(), timeoutPromise.promise]);
            if (next.done)
                break;
            yield next.value;
        }
    }
    finally {
        signal.removeEventListener("abort", listener);
    }
}
const aigneContextInvokeArgsSchema = zod_1.z.object({
    agent: zod_1.z.union([zod_1.z.custom(), zod_1.z.custom()]),
    message: zod_1.z.union([zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()), zod_1.z.string()]).optional(),
    options: zod_1.z.object({ returnActiveAgent: zod_1.z.boolean().optional() }).optional(),
});
