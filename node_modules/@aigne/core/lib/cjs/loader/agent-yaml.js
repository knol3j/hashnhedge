"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAgentFile = parseAgentFile;
exports.loadAgentFromYamlFile = loadAgentFromYamlFile;
const json_schema_to_zod_1 = require("@aigne/json-schema-to-zod");
const index_js_1 = require("@aigne/platform-helpers/nodejs/index.js");
const yaml_1 = require("yaml");
const zod_1 = require("zod");
const ai_agent_js_1 = require("../agents/ai-agent.js");
const team_agent_js_1 = require("../agents/team-agent.js");
const type_utils_js_1 = require("../utils/type-utils.js");
const schema_js_1 = require("./schema.js");
async function parseAgentFile(path, data) {
    const agentSchema = zod_1.z.lazy(() => {
        const nestAgentSchema = zod_1.z.lazy(() => zod_1.z.union([
            agentSchema,
            zod_1.z.string(),
            (0, schema_js_1.camelizeSchema)(zod_1.z.object({
                url: zod_1.z.string(),
                defaultInput: (0, schema_js_1.optionalize)(schema_js_1.defaultInputSchema),
                hooks: (0, schema_js_1.optionalize)(zod_1.z.union([hooksSchema, zod_1.z.array(hooksSchema)])),
            })),
        ]));
        const hooksSchema = (0, schema_js_1.camelizeSchema)(zod_1.z.object({
            priority: (0, schema_js_1.optionalize)(zod_1.z.union([zod_1.z.literal("low"), zod_1.z.literal("medium"), zod_1.z.literal("high")])),
            onStart: (0, schema_js_1.optionalize)(nestAgentSchema),
            onSuccess: (0, schema_js_1.optionalize)(nestAgentSchema),
            onError: (0, schema_js_1.optionalize)(nestAgentSchema),
            onEnd: (0, schema_js_1.optionalize)(nestAgentSchema),
            onSkillStart: (0, schema_js_1.optionalize)(nestAgentSchema),
            onSkillEnd: (0, schema_js_1.optionalize)(nestAgentSchema),
            onHandoff: (0, schema_js_1.optionalize)(nestAgentSchema),
        }));
        const baseAgentSchema = zod_1.z.object({
            name: (0, schema_js_1.optionalize)(zod_1.z.string()),
            alias: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
            description: (0, schema_js_1.optionalize)(zod_1.z.string()),
            taskTitle: (0, schema_js_1.optionalize)(zod_1.z.string()),
            taskRenderMode: (0, schema_js_1.optionalize)(zod_1.z.union([zod_1.z.literal("hide"), zod_1.z.literal("collapse")])),
            inputSchema: (0, schema_js_1.optionalize)((0, schema_js_1.inputOutputSchema)({ path })).transform((v) => v ? (0, json_schema_to_zod_1.jsonSchemaToZod)(v) : undefined),
            defaultInput: (0, schema_js_1.optionalize)(schema_js_1.defaultInputSchema),
            outputSchema: (0, schema_js_1.optionalize)((0, schema_js_1.inputOutputSchema)({ path })).transform((v) => v ? (0, json_schema_to_zod_1.jsonSchemaToZod)(v) : undefined),
            hooks: (0, schema_js_1.optionalize)(zod_1.z.union([hooksSchema, zod_1.z.array(hooksSchema)])),
            skills: (0, schema_js_1.optionalize)(zod_1.z.array(nestAgentSchema)),
            memory: (0, schema_js_1.optionalize)(zod_1.z.union([
                zod_1.z.boolean(),
                (0, schema_js_1.camelizeSchema)(zod_1.z.object({
                    provider: zod_1.z.string(),
                    subscribeTopic: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
                })),
            ])),
        });
        const instructionsSchema = zod_1.z
            .union([
            zod_1.z.string(),
            zod_1.z.object({
                url: zod_1.z.string(),
            }),
        ])
            .transform((v) => typeof v === "string"
            ? { content: v, path }
            : Promise.resolve(index_js_1.nodejs.path.join(index_js_1.nodejs.path.dirname(path), v.url)).then((path) => index_js_1.nodejs.fs.readFile(path, "utf8").then((content) => ({ content, path }))));
        return (0, schema_js_1.camelizeSchema)(zod_1.z.discriminatedUnion("type", [
            zod_1.z
                .object({
                type: zod_1.z.literal("ai"),
                instructions: (0, schema_js_1.optionalize)(instructionsSchema),
                inputKey: (0, schema_js_1.optionalize)(zod_1.z.string()),
                outputKey: (0, schema_js_1.optionalize)(zod_1.z.string()),
                toolChoice: (0, schema_js_1.optionalize)(zod_1.z.nativeEnum(ai_agent_js_1.AIAgentToolChoice)),
            })
                .extend(baseAgentSchema.shape),
            zod_1.z
                .object({
                type: zod_1.z.literal("image"),
                instructions: instructionsSchema,
                modelOptions: (0, schema_js_1.optionalize)((0, schema_js_1.camelizeSchema)(zod_1.z.record(zod_1.z.any()))),
            })
                .extend(baseAgentSchema.shape),
            zod_1.z
                .object({
                type: zod_1.z.literal("mcp"),
                url: (0, schema_js_1.optionalize)(zod_1.z.string()),
                command: (0, schema_js_1.optionalize)(zod_1.z.string()),
                args: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
            })
                .extend(baseAgentSchema.shape),
            zod_1.z
                .object({
                type: zod_1.z.literal("team"),
                mode: (0, schema_js_1.optionalize)(zod_1.z.nativeEnum(team_agent_js_1.ProcessMode)),
                iterateOn: (0, schema_js_1.optionalize)(zod_1.z.string()),
                concurrency: (0, schema_js_1.optionalize)(zod_1.z.number().int().min(1)),
                iterateWithPreviousOutput: (0, schema_js_1.optionalize)(zod_1.z.boolean()),
                includeAllStepsOutput: (0, schema_js_1.optionalize)(zod_1.z.boolean()),
                reflection: (0, schema_js_1.camelizeSchema)((0, schema_js_1.optionalize)(zod_1.z.object({
                    reviewer: nestAgentSchema,
                    isApproved: zod_1.z.string(),
                    maxIterations: (0, schema_js_1.optionalize)(zod_1.z.number().int().min(1)),
                    returnLastOnMaxIterations: (0, schema_js_1.optionalize)(zod_1.z.boolean()),
                }))),
            })
                .extend(baseAgentSchema.shape),
            zod_1.z
                .object({
                type: zod_1.z.literal("transform"),
                jsonata: zod_1.z.string(),
            })
                .extend(baseAgentSchema.shape),
            zod_1.z
                .object({
                type: zod_1.z.literal("function"),
                process: zod_1.z.custom(),
            })
                .extend(baseAgentSchema.shape),
        ]));
    });
    return agentSchema.parseAsync(data);
}
async function loadAgentFromYamlFile(path) {
    const raw = await (0, type_utils_js_1.tryOrThrow)(() => index_js_1.nodejs.fs.readFile(path, "utf8"), (error) => new Error(`Failed to load agent definition from ${path}: ${error.message}`));
    const json = (0, type_utils_js_1.tryOrThrow)(() => (0, yaml_1.parse)(raw), (error) => new Error(`Failed to parse agent definition from ${path}: ${error.message}`));
    const agent = await (0, type_utils_js_1.tryOrThrow)(async () => await parseAgentFile(path, {
        ...json,
        type: json.type ?? "ai",
        skills: json.skills ?? json.tools,
    }), (error) => new Error(`Failed to validate agent definition from ${path}: ${error.message}`));
    return agent;
}
