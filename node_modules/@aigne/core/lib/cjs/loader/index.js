"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = load;
exports.loadAgent = loadAgent;
exports.loadAIGNEFile = loadAIGNEFile;
const index_js_1 = require("@aigne/platform-helpers/nodejs/index.js");
const yaml_1 = require("yaml");
const zod_1 = require("zod");
const agent_js_1 = require("../agents/agent.js");
const ai_agent_js_1 = require("../agents/ai-agent.js");
const image_agent_js_1 = require("../agents/image-agent.js");
const mcp_agent_js_1 = require("../agents/mcp-agent.js");
const team_agent_js_1 = require("../agents/team-agent.js");
const transform_agent_js_1 = require("../agents/transform-agent.js");
const prompt_builder_js_1 = require("../prompt/prompt-builder.js");
const type_utils_js_1 = require("../utils/type-utils.js");
const agent_js_js_1 = require("./agent-js.js");
const agent_yaml_js_1 = require("./agent-yaml.js");
const schema_js_1 = require("./schema.js");
const AIGNE_FILE_NAME = ["aigne.yaml", "aigne.yml"];
async function load(path, options = {}) {
    options.key ??= Date.now();
    const { aigne, rootDir } = await loadAIGNEFile(path);
    const allAgentPaths = new Set((0, type_utils_js_1.flat)(aigne.agents, aigne.skills, aigne.mcpServer?.agents, aigne.cli?.agents, aigne.cli?.chat).map((i) => index_js_1.nodejs.path.join(rootDir, i)));
    const allAgents = Object.fromEntries(await Promise.all(Array.from(allAgentPaths).map(async (path) => [path, await loadAgent(path, options)])));
    const pickAgents = (paths) => paths.map((filename) => allAgents[index_js_1.nodejs.path.join(rootDir, filename)]).filter(type_utils_js_1.isNonNullable);
    return {
        ...aigne,
        rootDir,
        model: typeof options.model === "function" ? await options.model(aigne.chatModel) : options.model,
        imageModel: typeof options.imageModel === "function"
            ? await options.imageModel(aigne.imageModel)
            : options.imageModel,
        agents: pickAgents(aigne.agents ?? []),
        skills: pickAgents(aigne.skills ?? []),
        mcpServer: {
            agents: pickAgents(aigne.mcpServer?.agents ?? []),
        },
        cli: {
            chat: aigne.cli?.chat ? pickAgents([aigne.cli.chat])[0] : undefined,
            agents: pickAgents(aigne.cli?.agents ?? []),
        },
    };
}
async function loadAgent(path, options, agentOptions) {
    if ([".js", ".mjs", ".ts", ".mts"].includes(index_js_1.nodejs.path.extname(path))) {
        const agent = await (0, agent_js_js_1.loadAgentFromJsFile)(path, options);
        if (agent instanceof agent_js_1.Agent)
            return agent;
        return parseAgent(path, agent, options, agentOptions);
    }
    if ([".yml", ".yaml"].includes(index_js_1.nodejs.path.extname(path))) {
        const agent = await (0, agent_yaml_js_1.loadAgentFromYamlFile)(path);
        return parseAgent(path, agent, options, agentOptions);
    }
    throw new Error(`Unsupported agent file type: ${path}`);
}
async function loadNestAgent(path, agent, options) {
    return typeof agent === "object" && "type" in agent
        ? parseAgent(path, agent, options)
        : typeof agent === "string"
            ? loadAgent(index_js_1.nodejs.path.join(index_js_1.nodejs.path.dirname(path), agent), options)
            : loadAgent(index_js_1.nodejs.path.join(index_js_1.nodejs.path.dirname(path), agent.url), options, {
                defaultInput: agent.defaultInput,
                hooks: await parseHooks(path, agent.hooks, options),
            });
}
async function parseHooks(path, hooks, options) {
    hooks = [hooks].flat().filter(type_utils_js_1.isNonNullable);
    if (!hooks.length)
        return undefined;
    return await Promise.all(hooks.map(async (hook) => ({
        priority: hook.priority,
        onStart: hook.onStart ? await loadNestAgent(path, hook.onStart, options) : undefined,
        onSuccess: hook.onSuccess ? await loadNestAgent(path, hook.onSuccess, options) : undefined,
        onError: hook.onError ? await loadNestAgent(path, hook.onError, options) : undefined,
        onEnd: hook.onEnd ? await loadNestAgent(path, hook.onEnd, options) : undefined,
        onSkillStart: hook.onSkillStart
            ? await loadNestAgent(path, hook.onSkillStart, options)
            : undefined,
        onSkillEnd: hook.onSkillEnd
            ? await loadNestAgent(path, hook.onSkillEnd, options)
            : undefined,
        onHandoff: hook.onHandoff ? await loadNestAgent(path, hook.onHandoff, options) : undefined,
    })));
}
async function parseAgent(path, agent, options, agentOptions) {
    const skills = "skills" in agent
        ? agent.skills &&
            (await Promise.all(agent.skills.map((skill) => loadNestAgent(path, skill, options))))
        : undefined;
    const memory = "memory" in agent && options?.memories?.length
        ? await loadMemory(options.memories, typeof agent.memory === "object" ? agent.memory.provider : undefined, typeof agent.memory === "object" ? agent.memory : {})
        : undefined;
    const baseOptions = {
        ...agentOptions,
        ...agent,
        skills,
        memory,
        hooks: [
            ...((await parseHooks(path, agent.hooks, options)) ?? []),
            ...[agentOptions?.hooks].flat().filter(type_utils_js_1.isNonNullable),
        ],
    };
    let instructions;
    if ("instructions" in agent && agent.instructions) {
        instructions = prompt_builder_js_1.PromptBuilder.from(agent.instructions.content, {
            workingDir: index_js_1.nodejs.path.dirname(agent.instructions.path),
        });
    }
    switch (agent.type) {
        case "ai": {
            return ai_agent_js_1.AIAgent.from({
                ...baseOptions,
                instructions,
            });
        }
        case "image": {
            if (!instructions)
                throw new Error(`Missing required instructions for image agent at path: ${path}`);
            return image_agent_js_1.ImageAgent.from({
                ...baseOptions,
                instructions,
            });
        }
        case "mcp": {
            if (agent.url) {
                return mcp_agent_js_1.MCPAgent.from({
                    ...baseOptions,
                    url: agent.url,
                });
            }
            if (agent.command) {
                return mcp_agent_js_1.MCPAgent.from({
                    ...baseOptions,
                    command: agent.command,
                    args: agent.args,
                });
            }
            throw new Error(`Missing url or command in mcp agent: ${path}`);
        }
        case "team": {
            return team_agent_js_1.TeamAgent.from({
                ...baseOptions,
                mode: agent.mode,
                iterateOn: agent.iterateOn,
                reflection: agent.reflection && {
                    ...agent.reflection,
                    reviewer: await loadNestAgent(path, agent.reflection.reviewer, options),
                },
            });
        }
        case "transform": {
            return transform_agent_js_1.TransformAgent.from({
                ...baseOptions,
                jsonata: agent.jsonata,
            });
        }
        case "function": {
            return agent_js_1.FunctionAgent.from({
                ...baseOptions,
                process: agent.process,
            });
        }
    }
}
async function loadMemory(memories, provider, options) {
    const M = !provider
        ? memories[0]
        : memories.find((i) => i.name.toLowerCase().includes(provider.toLowerCase()));
    if (!M)
        throw new Error(`Unsupported memory: ${provider}`);
    return new M(options);
}
const aigneFileSchema = (0, schema_js_1.camelizeSchema)(zod_1.z.object({
    name: (0, schema_js_1.optionalize)(zod_1.z.string()),
    description: (0, schema_js_1.optionalize)(zod_1.z.string()),
    chatModel: zod_1.z
        .preprocess((v) => {
        if (!(0, type_utils_js_1.isRecord)(v))
            return v;
        return { ...v, model: v.model || `${v.provider || ""}:${v.name || ""}` };
    }, (0, schema_js_1.optionalize)(zod_1.z.union([
        zod_1.z.string(),
        (0, schema_js_1.camelizeSchema)(zod_1.z.object({
            model: (0, schema_js_1.optionalize)(zod_1.z.string()),
            temperature: (0, schema_js_1.optionalize)(zod_1.z.number().min(0).max(2)),
            topP: (0, schema_js_1.optionalize)(zod_1.z.number().min(0)),
            frequencyPenalty: (0, schema_js_1.optionalize)(zod_1.z.number().min(-2).max(2)),
            presencePenalty: (0, schema_js_1.optionalize)(zod_1.z.number().min(-2).max(2)),
        })),
    ])))
        .transform((v) => (typeof v === "string" ? { model: v } : v)),
    imageModel: (0, schema_js_1.optionalize)(zod_1.z.union([
        zod_1.z.string(),
        (0, schema_js_1.camelizeSchema)(zod_1.z.object({
            model: (0, schema_js_1.optionalize)(zod_1.z.string()),
        })),
    ])).transform((v) => (typeof v === "string" ? { model: v } : v)),
    agents: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
    skills: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
    mcpServer: (0, schema_js_1.optionalize)(zod_1.z.object({
        agents: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
    })),
    cli: (0, schema_js_1.optionalize)(zod_1.z.object({
        chat: (0, schema_js_1.optionalize)(zod_1.z.string()),
        agents: (0, schema_js_1.optionalize)(zod_1.z.array(zod_1.z.string())),
    })),
}));
async function loadAIGNEFile(path) {
    const file = await findAIGNEFile(path);
    const raw = await (0, type_utils_js_1.tryOrThrow)(() => index_js_1.nodejs.fs.readFile(file, "utf8"), (error) => new Error(`Failed to load aigne.yaml from ${file}: ${error.message}`));
    const json = (0, type_utils_js_1.tryOrThrow)(() => (0, yaml_1.parse)(raw), (error) => new Error(`Failed to parse aigne.yaml from ${file}: ${error.message}`));
    const aigne = (0, type_utils_js_1.tryOrThrow)(() => aigneFileSchema.parse(json), (error) => new Error(`Failed to validate aigne.yaml from ${file}: ${error.message}`));
    return { aigne, rootDir: index_js_1.nodejs.path.dirname(file) };
}
async function findAIGNEFile(path) {
    const possibleFiles = AIGNE_FILE_NAME.includes(index_js_1.nodejs.path.basename(path))
        ? [path]
        : AIGNE_FILE_NAME.map((name) => index_js_1.nodejs.path.join(path, name));
    for (const file of possibleFiles) {
        try {
            const stat = await index_js_1.nodejs.fs.stat(file);
            if (stat.isFile())
                return file;
        }
        catch { }
    }
    throw new Error(`aigne.yaml not found in ${path}. Please ensure you are in the correct directory or provide a valid path.`);
}
