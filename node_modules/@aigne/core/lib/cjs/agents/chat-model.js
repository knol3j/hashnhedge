"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chatModelOutputUsageSchema = exports.ChatModel = exports.StructuredOutputError = void 0;
const ajv_1 = require("ajv");
const is_network_error_1 = __importDefault(require("is-network-error"));
const zod_1 = require("zod");
const type_utils_js_1 = require("../utils/type-utils.js");
const agent_js_1 = require("./agent.js");
const CHAT_MODEL_DEFAULT_RETRY_OPTIONS = {
    retries: 3,
    shouldRetry: (error) => error instanceof StructuredOutputError || (0, is_network_error_1.default)(error),
};
class StructuredOutputError extends Error {
}
exports.StructuredOutputError = StructuredOutputError;
/**
 * ChatModel is an abstract base class for interacting with Large Language Models (LLMs).
 *
 * This class extends the Agent class and provides a common interface for handling model inputs,
 * outputs, and capabilities. Specific model implementations (like OpenAI, Anthropic, etc.)
 * should inherit from this class and implement their specific functionalities.
 *
 * @example
 * Here's how to implement a custom ChatModel:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model}
 *
 * @example
 * Here's an example showing streaming response with readable stream:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-streaming}
 *
 * @example
 * Here's an example showing streaming response with async generator:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-streaming-async-generator}
 *
 * @example
 * Here's an example with tool calls:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-tools}
 */
class ChatModel extends agent_js_1.Agent {
    tag = "ChatModelAgent";
    constructor(options) {
        if (options)
            (0, type_utils_js_1.checkArguments)("ChatModel", agent_js_1.agentOptionsSchema, options);
        const retryOnError = options?.retryOnError === false
            ? false
            : options?.retryOnError === true
                ? CHAT_MODEL_DEFAULT_RETRY_OPTIONS
                : {
                    ...CHAT_MODEL_DEFAULT_RETRY_OPTIONS,
                    ...options?.retryOnError,
                };
        super({
            ...options,
            inputSchema: chatModelInputSchema,
            outputSchema: chatModelOutputSchema,
            retryOnError,
        });
    }
    get credential() {
        return {};
    }
    /**
     * Indicates whether the model supports parallel tool calls
     *
     * Defaults to true, subclasses can override this property based on
     * specific model capabilities
     */
    supportsParallelToolCalls = true;
    /**
     * Gets the model's supported capabilities
     *
     * Currently returns capabilities including: whether parallel tool calls are supported
     *
     * @returns An object containing model capabilities
     */
    getModelCapabilities() {
        return {
            supportsParallelToolCalls: this.supportsParallelToolCalls,
        };
    }
    validateToolNames(tools) {
        for (const tool of tools ?? []) {
            if (!/^[a-zA-Z0-9_]+$/.test(tool.function.name)) {
                throw new Error(`Tool name "${tool.function.name}" can only contain letters, numbers, and underscores`);
            }
        }
    }
    /**
     * Normalizes tool names to ensure compatibility with language models
     *
     * This method converts tool names to a format that complies with model requirements
     * by replacing hyphens and whitespace characters with underscores. The normalized
     * names are used for tool calls while preserving the original names for reference.
     *
     * @param name - The original tool name to normalize
     * @returns A promise that resolves to the normalized tool name
     */
    async normalizeToolName(name) {
        return name.replaceAll(/[-\s]/g, "_");
    }
    /**
     * Performs preprocessing operations before handling input
     *
     * Primarily checks if token usage exceeds limits, throwing an exception if limits are exceeded
     *
     * @param input Input message
     * @param options Options for invoking the agent
     * @throws Error if token usage exceeds maximum limit
     */
    async preprocess(input, options) {
        super.preprocess(input, options);
        const { limits, usage } = options.context;
        const usedTokens = usage.outputTokens + usage.inputTokens;
        if (limits?.maxTokens && usedTokens >= limits.maxTokens) {
            throw new Error(`Exceeded max tokens ${usedTokens}/${limits.maxTokens}`);
        }
        // Automatically convert tool names to a valid format
        if (input.tools?.length) {
            const toolsMap = {};
            const tools = [];
            for (const originalTool of input.tools) {
                const name = await this.normalizeToolName(originalTool.function.name);
                const tool = {
                    ...originalTool,
                    function: { ...originalTool.function, name },
                };
                tools.push(tool);
                toolsMap[name] = originalTool;
            }
            this.validateToolNames(tools);
            Object.assign(input, { tools });
            Object.defineProperty(input, "_toolsMap", {
                value: toolsMap,
                enumerable: false,
            });
        }
    }
    /**
     * Performs postprocessing operations after handling output
     *
     * Primarily updates token usage statistics in the context
     *
     * @param input Input message
     * @param output Output message
     * @param options Options for invoking the agent
     */
    async postprocess(input, output, options) {
        // Restore original tool names in the output
        if (output.toolCalls?.length) {
            const toolsMap = input._toolsMap;
            if (toolsMap) {
                for (const toolCall of output.toolCalls) {
                    const originalTool = toolsMap[toolCall.function.name];
                    if (!originalTool) {
                        throw new Error(`Tool "${toolCall.function.name}" not found in tools map`);
                    }
                    toolCall.function.name = originalTool.function.name;
                }
            }
        }
        if (input.responseFormat?.type === "json_schema" &&
            // NOTE: Should not validate if there are tool calls
            !output.toolCalls?.length) {
            const ajv = new ajv_1.Ajv();
            if (!ajv.validate(input.responseFormat.jsonSchema.schema, output.json)) {
                throw new StructuredOutputError(`Output JSON does not conform to the provided JSON schema: ${ajv.errorsText()}`);
            }
        }
        super.postprocess(input, output, options);
        const { usage } = output;
        if (usage) {
            options.context.usage.outputTokens += usage.outputTokens;
            options.context.usage.inputTokens += usage.inputTokens;
            if (usage.aigneHubCredits)
                options.context.usage.aigneHubCredits += usage.aigneHubCredits;
        }
    }
}
exports.ChatModel = ChatModel;
const chatModelInputMessageSchema = zod_1.z.object({
    role: zod_1.z.union([zod_1.z.literal("system"), zod_1.z.literal("user"), zod_1.z.literal("agent"), zod_1.z.literal("tool")]),
    content: zod_1.z
        .union([
        zod_1.z.string(),
        zod_1.z.array(zod_1.z.union([
            zod_1.z.object({ type: zod_1.z.literal("text"), text: zod_1.z.string() }),
            zod_1.z.object({ type: zod_1.z.literal("image_url"), url: zod_1.z.string() }),
        ])),
    ])
        .optional(),
    toolCalls: zod_1.z
        .array(zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.literal("function"),
        function: zod_1.z.object({
            name: zod_1.z.string(),
            arguments: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
        }),
    }))
        .optional(),
    toolCallId: zod_1.z.string().optional(),
    name: zod_1.z.string().optional(),
});
const chatModelInputResponseFormatSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({ type: zod_1.z.literal("text") }),
    zod_1.z.object({
        type: zod_1.z.literal("json_schema"),
        jsonSchema: zod_1.z.object({
            name: zod_1.z.string(),
            description: zod_1.z.string().optional(),
            schema: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
            strict: zod_1.z.boolean().optional(),
        }),
    }),
]);
const chatModelInputToolSchema = zod_1.z.object({
    type: zod_1.z.literal("function"),
    function: zod_1.z.object({
        name: zod_1.z.string(),
        description: zod_1.z.string().optional(),
        parameters: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    }),
});
const chatModelInputToolChoiceSchema = zod_1.z.union([
    zod_1.z.literal("auto"),
    zod_1.z.literal("none"),
    zod_1.z.literal("required"),
    chatModelInputToolSchema,
]);
const chatModelOptionsSchema = zod_1.z.object({
    model: zod_1.z.string().optional(),
    temperature: zod_1.z.number().optional(),
    topP: zod_1.z.number().optional(),
    frequencyPenalty: zod_1.z.number().optional(),
    presencePenalty: zod_1.z.number().optional(),
    parallelToolCalls: zod_1.z.boolean().optional().default(true),
});
const chatModelInputSchema = zod_1.z.object({
    messages: zod_1.z.array(chatModelInputMessageSchema),
    responseFormat: chatModelInputResponseFormatSchema.optional(),
    tools: zod_1.z.array(chatModelInputToolSchema).optional(),
    toolChoice: chatModelInputToolChoiceSchema.optional(),
    modelOptions: chatModelOptionsSchema.optional(),
});
const chatModelOutputToolCallSchema = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.literal("function"),
    function: zod_1.z.object({
        name: zod_1.z.string(),
        arguments: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    }),
});
exports.chatModelOutputUsageSchema = zod_1.z.object({
    inputTokens: zod_1.z.number(),
    outputTokens: zod_1.z.number(),
    aigneHubCredits: zod_1.z.number().optional(),
});
const chatModelOutputSchema = zod_1.z.object({
    text: zod_1.z.string().optional(),
    json: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    toolCalls: zod_1.z.array(chatModelOutputToolCallSchema).optional(),
    usage: exports.chatModelOutputUsageSchema.optional(),
    model: zod_1.z.string().optional(),
});
