"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryAgent = exports.newMemoryId = void 0;
const uuid_1 = require("uuid");
const zod_1 = require("zod");
const agent_js_1 = require("../agents/agent.js");
const type_utils_js_1 = require("../utils/type-utils.js");
const recorder_js_1 = require("./recorder.js");
const retriever_js_1 = require("./retriever.js");
const newMemoryId = () => (0, uuid_1.v7)();
exports.newMemoryId = newMemoryId;
/**
 * A specialized agent responsible for managing, storing, and retrieving memories within the agent system.
 *
 * MemoryAgent serves as a bridge between application logic and memory storage/retrieval mechanisms.
 * It delegates the actual memory operations to specialized recorder and retriever agents that
 * are attached as skills. This agent doesn't directly process messages like other agents but
 * instead provides memory management capabilities to the system.
 */
class MemoryAgent extends agent_js_1.Agent {
    tag = "MemoryAgent";
    /**
     * Creates a new MemoryAgent instance.
     */
    constructor(options) {
        (0, type_utils_js_1.checkArguments)("MemoryAgent", memoryAgentOptionsSchema, options);
        super({
            subscribeTopic: options.subscribeTopic,
            skills: options.skills,
        });
        this.recorder =
            options.recorder instanceof recorder_js_1.MemoryRecorder
                ? options.recorder
                : options.recorder &&
                    new recorder_js_1.MemoryRecorder(typeof options.recorder === "function"
                        ? { process: options.recorder }
                        : options.recorder);
        this.retriever =
            options.retriever instanceof retriever_js_1.MemoryRetriever
                ? options.retriever
                : options.retriever &&
                    new retriever_js_1.MemoryRetriever(typeof options.retriever === "function"
                        ? { process: options.retriever }
                        : options.retriever);
        this.autoUpdate = options.autoUpdate;
    }
    _retriever;
    /**
     * Agent used for retrieving memories from storage.
     *
     * This retriever is automatically added to the agent's skills when set.
     * Setting a new retriever will remove any previously set retriever from skills.
     */
    get retriever() {
        return this._retriever;
    }
    set retriever(value) {
        if (this._retriever)
            (0, type_utils_js_1.remove)(this.skills, [this._retriever]);
        this._retriever = value;
        if (value)
            this.skills.push(value);
    }
    _recorder;
    /**
     * Agent used for recording and storing new memories.
     *
     * This recorder is automatically added to the agent's skills when set.
     * Setting a new recorder will remove any previously set recorder from skills.
     */
    get recorder() {
        return this._recorder;
    }
    set recorder(value) {
        if (this._recorder)
            (0, type_utils_js_1.remove)(this.skills, [this._recorder]);
        this._recorder = value;
        if (value)
            this.skills.push(value);
    }
    /**
     * Controls whether to automatically update the memory when agent call completes.
     *
     * When true, the agent will automatically record any relevant information
     * after completing operations, creating a history of interactions.
     */
    autoUpdate;
    /**
     * Indicates whether this agent can be directly called.
     *
     * MemoryAgent is designed to be used as a supporting component rather than
     * being directly invoked for processing, so this returns false.
     */
    get isCallable() {
        return false;
    }
    /**
     * The standard message processing method required by the Agent interface.
     *
     * MemoryAgent doesn't directly process messages like other agents, so this method
     * throws an error when called. Use the specialized retrieve() and record() methods instead.
     */
    async process(_input, _options) {
        throw new Error("Method not implemented.");
    }
    /**
     * Retrieves memories based on the provided input criteria.
     *
     * Delegates the actual retrieval operation to the configured retriever agent.
     *
     * @param input - The retrieval parameters (can include search terms, limits, etc.)
     * @param context - The execution context
     * @returns A promise resolving to the retrieved memories
     * @throws Error - If no retriever has been initialized
     */
    async retrieve(input, context) {
        if (!this.retriever)
            throw new Error("MemoryAgent retriever not initialized");
        return context.invoke(this.retriever, input);
    }
    /**
     * Records new memories based on the provided input content.
     *
     * Delegates the actual recording operation to the configured recorder agent.
     *
     * @param input - The content to be recorded as memories
     * @param context - The execution context
     * @returns A promise resolving to the recorded memories
     * @throws Error - If no recorder has been initialized
     */
    async record(input, context) {
        if (!this.recorder)
            throw new Error("MemoryAgent recorder not initialized");
        return context.invoke(this.recorder, input);
    }
    async onMessage({ role, source, message, context }) {
        this.record({ content: [role === "user" ? { input: message } : { output: message, source }] }, context);
    }
}
exports.MemoryAgent = MemoryAgent;
const memoryAgentOptionsSchema = zod_1.z.object({
    retriever: zod_1.z.custom().optional(),
    recorder: zod_1.z.custom().optional(),
    autoUpdate: zod_1.z.boolean().optional(),
    subscribeTopic: zod_1.z.union([zod_1.z.string(), zod_1.z.array(zod_1.z.string())]).optional(),
    skills: zod_1.z.array(zod_1.z.custom()).optional(),
});
