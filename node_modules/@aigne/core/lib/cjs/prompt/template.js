"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatMessagesTemplate = exports.ToolMessageTemplate = exports.AgentMessageTemplate = exports.UserMessageTemplate = exports.SystemMessageTemplate = exports.ChatMessageTemplate = exports.CustomLoader = exports.PromptTemplate = void 0;
exports.parseChatMessages = parseChatMessages;
const index_js_1 = require("@aigne/platform-helpers/nodejs/index.js");
const nunjucks_1 = __importDefault(require("nunjucks"));
const zod_1 = require("zod");
const type_utils_js_1 = require("../utils/type-utils.js");
nunjucks_1.default.runtime.suppressValue = (v) => {
    if ((0, type_utils_js_1.isNil)(v))
        return "";
    return typeof v === "object" ? JSON.stringify(v) : v;
};
class PromptTemplate {
    template;
    static from(template) {
        return new PromptTemplate(template);
    }
    constructor(template) {
        this.template = template;
    }
    async format(variables = {}, options) {
        let env = new nunjucks_1.default.Environment();
        if (options?.workingDir) {
            env = new nunjucks_1.default.Environment(new CustomLoader({ workingDir: options.workingDir }));
        }
        return new Promise((resolve, reject) => env.renderString(this.template, variables, (err, res) => {
            if (err || !res) {
                reject(err || new Error(`Failed to render template: ${this.template}`));
            }
            else {
                resolve(res);
            }
        }));
    }
}
exports.PromptTemplate = PromptTemplate;
class CustomLoader extends nunjucks_1.default.Loader {
    options;
    constructor(options) {
        super();
        this.options = options;
    }
    async = true;
    isRelative(filename) {
        return !index_js_1.nodejs.path.isAbsolute(filename);
    }
    resolve(from, to) {
        return index_js_1.nodejs.path.resolve(index_js_1.nodejs.path.dirname(from), to);
    }
    getSource(name, callback) {
        let result = null;
        const path = index_js_1.nodejs.path.isAbsolute(name)
            ? name
            : index_js_1.nodejs.path.join(this.options.workingDir, name);
        index_js_1.nodejs.fs.readFile(path, "utf-8").then((content) => {
            result = {
                src: content,
                path,
                noCache: true,
            };
            callback(null, result);
        }, (error) => {
            callback(error, null);
        });
        // nunjucks expects return LoaderSource synchronously, but we handle it asynchronously.
        return result;
    }
}
exports.CustomLoader = CustomLoader;
class ChatMessageTemplate {
    role;
    content;
    name;
    constructor(role, content, name) {
        this.role = role;
        this.content = content;
        this.name = name;
    }
    async format(variables, options) {
        let { content } = this;
        if (Array.isArray(content)) {
            content = await Promise.all(content.map(async (i) => {
                if (i.type === "text")
                    return { ...i, text: await PromptTemplate.from(i.text).format(variables, options) };
                return i;
            }));
        }
        else if (typeof content === "string") {
            content = await PromptTemplate.from(content).format(variables, options);
        }
        return {
            role: this.role,
            content,
            name: this.name,
        };
    }
}
exports.ChatMessageTemplate = ChatMessageTemplate;
class SystemMessageTemplate extends ChatMessageTemplate {
    static from(content, name) {
        return new SystemMessageTemplate("system", content, name);
    }
}
exports.SystemMessageTemplate = SystemMessageTemplate;
class UserMessageTemplate extends ChatMessageTemplate {
    static from(template, name) {
        return new UserMessageTemplate("user", template, name);
    }
}
exports.UserMessageTemplate = UserMessageTemplate;
class AgentMessageTemplate extends ChatMessageTemplate {
    toolCalls;
    static from(template, toolCalls, name) {
        return new AgentMessageTemplate(template, toolCalls, name);
    }
    constructor(content, toolCalls, name) {
        super("agent", content, name);
        this.toolCalls = toolCalls;
    }
    async format(variables, options) {
        return {
            ...(await super.format(variables, options)),
            toolCalls: this.toolCalls,
        };
    }
}
exports.AgentMessageTemplate = AgentMessageTemplate;
class ToolMessageTemplate extends ChatMessageTemplate {
    toolCallId;
    static from(content, toolCallId, name) {
        return new ToolMessageTemplate(content, toolCallId, name);
    }
    constructor(content, toolCallId, name) {
        super("tool", typeof content === "string"
            ? content
            : JSON.stringify(content, (_, value) => typeof value === "bigint" ? value.toString() : value), name);
        this.toolCallId = toolCallId;
    }
    async format(variables, options) {
        return {
            ...(await super.format(variables, options)),
            toolCallId: this.toolCallId,
        };
    }
}
exports.ToolMessageTemplate = ToolMessageTemplate;
class ChatMessagesTemplate {
    messages;
    static from(messages) {
        return new ChatMessagesTemplate(typeof messages === "string" ? [UserMessageTemplate.from(messages)] : messages);
    }
    constructor(messages) {
        this.messages = messages;
    }
    async format(variables, options) {
        return Promise.all(this.messages.map((message) => message.format(variables, options)));
    }
}
exports.ChatMessagesTemplate = ChatMessagesTemplate;
const systemChatMessageSchema = zod_1.z.object({
    role: zod_1.z.literal("system"),
    content: zod_1.z.string(),
    name: zod_1.z.string().optional(),
});
const userChatMessageSchema = zod_1.z.object({
    role: zod_1.z.literal("user"),
    content: zod_1.z.string(),
    name: zod_1.z.string().optional(),
});
const chatModelOutputToolCallSchema = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.literal("function"),
    function: zod_1.z.object({
        name: zod_1.z.string(),
        arguments: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    }),
});
const agentChatMessageSchema = zod_1.z.object({
    role: zod_1.z.literal("agent"),
    content: zod_1.z.string().optional(),
    toolCalls: zod_1.z.array(chatModelOutputToolCallSchema).optional(),
    name: zod_1.z.string().optional(),
});
const toolChatMessageSchema = zod_1.z.object({
    role: zod_1.z.literal("tool"),
    content: zod_1.z
        .union([zod_1.z.string(), zod_1.z.record(zod_1.z.string(), zod_1.z.unknown())])
        .transform((val) => (typeof val !== "string" ? JSON.stringify(val) : val)),
    toolCallId: zod_1.z.string(),
    name: zod_1.z.string().optional(),
});
const chatMessageSchema = zod_1.z.union([
    systemChatMessageSchema,
    userChatMessageSchema,
    agentChatMessageSchema,
    toolChatMessageSchema,
]);
const chatMessagesSchema = zod_1.z.array(chatMessageSchema);
function parseChatMessages(messages) {
    const result = chatMessagesSchema.safeParse(messages);
    if (!result.success)
        return undefined;
    return result.data.map((message) => {
        switch (message.role) {
            case "system":
                return SystemMessageTemplate.from(message.content, message.name);
            case "user":
                return UserMessageTemplate.from(message.content, message.name);
            case "agent":
                return AgentMessageTemplate.from(message.content, message.toolCalls, message.name);
            case "tool":
                return ToolMessageTemplate.from(message.content, message.toolCallId, message.name);
        }
    });
}
