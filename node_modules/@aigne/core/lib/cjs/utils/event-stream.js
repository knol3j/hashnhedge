"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentResponseProgressStream = exports.AgentResponseStreamSSE = exports.AgentResponseStreamParser = exports.EventStreamParser = void 0;
const eventsource_parser_1 = require("eventsource-parser");
const immer_1 = require("immer");
const agent_js_1 = require("../agents/agent.js");
const type_utils_js_1 = require("./type-utils.js");
class EventStreamParser extends TransformStream {
    constructor() {
        let parser;
        super({
            start(controller) {
                parser = (0, eventsource_parser_1.createParser)({
                    onEvent: (event) => {
                        const json = (0, type_utils_js_1.tryOrThrow)(() => JSON.parse(event.data), (e) => {
                            controller.enqueue(new Error(`Parse response chunk json error: ${e.message} ${event.data}`));
                        });
                        if (json) {
                            switch (event.event) {
                                case "error":
                                    controller.enqueue(new Error(json.message));
                                    break;
                                default: {
                                    if (!event.event)
                                        controller.enqueue(json);
                                    else
                                        console.warn(`Unknown event type: ${event.event}`, event.data);
                                }
                            }
                        }
                    },
                });
            },
            transform(chunk) {
                parser?.feed(chunk);
            },
        });
    }
}
exports.EventStreamParser = EventStreamParser;
class AgentResponseStreamParser extends TransformStream {
    json = {};
    constructor() {
        super({
            transform: (chunk, controller) => {
                if (chunk instanceof Error) {
                    controller.error(chunk);
                    controller.terminate();
                    return;
                }
                if ((0, agent_js_1.isAgentResponseDelta)(chunk)) {
                    this.json = (0, immer_1.produce)(this.json, (draft) => {
                        if (chunk.delta.json)
                            Object.assign(draft, chunk.delta.json);
                        if (chunk.delta.text) {
                            for (const [key, text] of Object.entries(chunk.delta.text)) {
                                const original = draft[key];
                                const t = (original || "") + (text || "");
                                if (t)
                                    Object.assign(draft, { [key]: t });
                            }
                        }
                    });
                    controller.enqueue({
                        ...chunk,
                        delta: {
                            ...chunk.delta,
                            json: this.json,
                        },
                    });
                }
                else if ((0, agent_js_1.isAgentResponseProgress)(chunk)) {
                    if (chunk.progress.event === "agentFailed") {
                        const { name, message } = chunk.progress.error;
                        chunk.progress.error = new Error(message);
                        chunk.progress.error.name = name;
                    }
                    controller.enqueue(chunk);
                }
            },
        });
    }
}
exports.AgentResponseStreamParser = AgentResponseStreamParser;
class AgentResponseStreamSSE extends ReadableStream {
    constructor(stream) {
        let reader;
        super({
            async pull(controller) {
                reader ??= stream.getReader();
                try {
                    const { value, done } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if ((0, agent_js_1.isAgentResponseProgress)(value)) {
                        if (value.progress.event === "agentFailed") {
                            value.progress.error = {
                                name: value.progress.error.name,
                                message: value.progress.error.message,
                            };
                        }
                    }
                    controller.enqueue(`data: ${JSON.stringify(value)}\n\n`);
                }
                catch (error) {
                    controller.enqueue(`event: error\ndata: ${JSON.stringify({ message: error.message })}\n\n`);
                    controller.close();
                }
            },
        });
    }
}
exports.AgentResponseStreamSSE = AgentResponseStreamSSE;
class AgentResponseProgressStream extends ReadableStream {
    constructor(context) {
        super({
            async start(controller) {
                const writeEvent = (eventName, event) => {
                    const progress = {
                        ...event,
                        event: eventName,
                        agent: { name: event.agent.name },
                    };
                    controller.enqueue({ progress });
                };
                const close = () => {
                    context.off("agentStarted", onAgentStarted);
                    context.off("agentSucceed", onAgentSucceed);
                    context.off("agentFailed", onAgentFailed);
                    controller.close();
                };
                const onAgentStarted = async (event) => {
                    const taskTitle = await event.agent.renderTaskTitle(event.input);
                    writeEvent("agentStarted", { ...event, taskTitle });
                };
                const onAgentSucceed = (event) => {
                    writeEvent("agentSucceed", event);
                    if (event.contextId === context.id) {
                        close();
                    }
                };
                const onAgentFailed = (event) => {
                    writeEvent("agentFailed", event);
                    if (event.contextId === context.id) {
                        close();
                    }
                };
                context.on("agentStarted", onAgentStarted);
                context.on("agentSucceed", onAgentSucceed);
                context.on("agentFailed", onAgentFailed);
            },
        });
    }
}
exports.AgentResponseProgressStream = AgentResponseProgressStream;
