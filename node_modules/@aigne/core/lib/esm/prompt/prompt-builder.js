import { nodejs } from "@aigne/platform-helpers/nodejs/index.js";
import { stringify } from "yaml";
import { ZodObject } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { Agent } from "../agents/agent.js";
import { outputSchemaToResponseFormatSchema } from "../utils/json-schema.js";
import { isNil, isRecord, unique } from "../utils/type-utils.js";
import { MEMORY_MESSAGE_TEMPLATE } from "./prompts/memory-message-template.js";
import { STRUCTURED_STREAM_INSTRUCTIONS } from "./prompts/structured-stream-instructions.js";
import { AgentMessageTemplate, ChatMessagesTemplate, PromptTemplate, SystemMessageTemplate, UserMessageTemplate, } from "./template.js";
export class PromptBuilder {
    static from(instructions, { workingDir } = {}) {
        if (typeof instructions === "string")
            return new PromptBuilder({ instructions, workingDir: workingDir });
        if (isFromPromptResult(instructions))
            return PromptBuilder.fromMCPPromptResult(instructions);
        if (isFromPath(instructions))
            return PromptBuilder.fromFile(instructions.path, { workingDir });
        throw new Error(`Invalid instructions ${instructions}`);
    }
    static fromFile(path, { workingDir }) {
        const text = nodejs.fsSync.readFileSync(path, "utf-8");
        return PromptBuilder.from(text, { workingDir: workingDir || nodejs.path.dirname(path) });
    }
    static fromMCPPromptResult(result) {
        return new PromptBuilder({
            instructions: ChatMessagesTemplate.from(result.messages.map((i) => {
                let content;
                if (i.content.type === "text")
                    content = i.content.text;
                else if (i.content.type === "resource") {
                    const { resource } = i.content;
                    if (typeof resource.text === "string") {
                        content = resource.text;
                    }
                    else if (typeof resource.blob === "string") {
                        content = [{ type: "image_url", url: resource.blob }];
                    }
                }
                else if (i.content.type === "image") {
                    content = [{ type: "image_url", url: i.content.data }];
                }
                if (!content)
                    throw new Error(`Unsupported content type ${i.content.type}`);
                if (i.role === "user")
                    return UserMessageTemplate.from(content);
                if (i.role === "assistant")
                    return AgentMessageTemplate.from(content);
                throw new Error(`Unsupported role ${i.role}`);
            })),
        });
    }
    constructor(options) {
        this.instructions = options?.instructions;
        this.workingDir = options?.workingDir;
    }
    instructions;
    workingDir;
    async build(options) {
        return {
            messages: await this.buildMessages(options),
            responseFormat: options.agent?.structuredStreamMode
                ? undefined
                : this.buildResponseFormat(options),
            ...this.buildTools(options),
        };
    }
    async buildImagePrompt(options) {
        const messages = (await (typeof this.instructions === "string"
            ? ChatMessagesTemplate.from([SystemMessageTemplate.from(this.instructions)])
            : this.instructions)?.format(options.input, { workingDir: this.workingDir })) ?? [];
        return {
            prompt: messages.map((i) => i.content).join("\n"),
        };
    }
    async buildMessages(options) {
        const { input } = options;
        const inputKey = options.agent?.inputKey;
        const message = inputKey && typeof input?.[inputKey] === "string" ? input[inputKey] : undefined;
        const messages = (await (typeof this.instructions === "string"
            ? ChatMessagesTemplate.from([SystemMessageTemplate.from(this.instructions)])
            : this.instructions)?.format(options.input, { workingDir: this.workingDir })) ?? [];
        const memories = [];
        if (options.agent && options.context) {
            memories.push(...(await options.agent.retrieveMemories({ search: message }, { context: options.context })));
        }
        if (options.agent?.useMemoriesFromContext && options.context?.memories?.length) {
            memories.push(...options.context.memories);
        }
        if (memories.length)
            messages.push(...(await this.convertMemoriesToMessages(memories, options)));
        // if the agent is using structured stream mode, add the instructions
        const { structuredStreamMode, outputSchema } = options.agent || {};
        if (structuredStreamMode && outputSchema) {
            const instructions = options.agent?.customStructuredStreamInstructions?.instructions ||
                PromptBuilder.from(STRUCTURED_STREAM_INSTRUCTIONS.instructions);
            messages.push(...(await instructions.buildMessages({
                input: {
                    ...input,
                    outputJsonSchema: zodToJsonSchema(outputSchema),
                },
            })));
        }
        if (message) {
            messages.push({
                role: "user",
                content: message,
            });
        }
        return messages;
    }
    async convertMemoriesToMessages(memories, options) {
        const messages = [];
        const other = [];
        const stringOrStringify = (value) => typeof value === "string" ? value : stringify(value);
        for (const { content } of memories) {
            if (isRecord(content) && "input" in content && "output" in content) {
                if (!isNil(content.input) && content.input !== "") {
                    messages.push({ role: "user", content: stringOrStringify(content.input) });
                }
                if (!isNil(content.output) && content.output !== "") {
                    messages.push({ role: "agent", content: stringOrStringify(content.output) });
                }
            }
            else {
                other.push(content);
            }
        }
        if (other.length) {
            messages.unshift({
                role: "system",
                content: await PromptTemplate.from(options.agent?.memoryPromptTemplate || MEMORY_MESSAGE_TEMPLATE).format({ memories: stringify(other) }),
            });
        }
        return messages;
    }
    buildResponseFormat(options) {
        const outputSchema = options.outputSchema || options.agent?.outputSchema;
        if (!outputSchema)
            return undefined;
        const isJsonOutput = !isEmptyObjectType(outputSchema);
        return isJsonOutput
            ? {
                type: "json_schema",
                jsonSchema: {
                    name: "output",
                    schema: outputSchemaToResponseFormatSchema(outputSchema),
                    strict: true,
                },
            }
            : undefined;
    }
    buildTools(options) {
        const toolAgents = unique((options.context?.skills ?? [])
            .concat(options.agent?.skills ?? [])
            .concat(options.agent?.memoryAgentsAsTools ? options.agent.memories : [])
            .flatMap((i) => (i.isInvokable ? i : i.skills)), (i) => i.name);
        const tools = toolAgents.map((i) => ({
            type: "function",
            function: {
                name: i.name,
                description: i.description,
                parameters: !isEmptyObjectType(i.inputSchema)
                    ? outputSchemaToResponseFormatSchema(i.inputSchema)
                    : {},
            },
        }));
        let toolChoice;
        const modelOptions = {};
        // use manual choice if configured in the agent
        const manualChoice = options.agent?.toolChoice;
        if (manualChoice) {
            if (manualChoice instanceof Agent) {
                toolChoice = {
                    type: "function",
                    function: {
                        name: manualChoice.name,
                        description: manualChoice.description,
                    },
                };
            }
            else if (manualChoice === "router") {
                toolChoice = "required";
                modelOptions.parallelToolCalls = false;
            }
            else {
                toolChoice = manualChoice;
            }
        }
        // otherwise, use auto choice if there is only one tool
        else {
            toolChoice = tools.length ? "auto" : undefined;
        }
        return {
            toolAgents: toolAgents.length ? toolAgents : undefined,
            tools: tools.length ? tools : undefined,
            toolChoice,
            modelOptions: Object.keys(modelOptions).length ? modelOptions : undefined,
        };
    }
}
function isFromPromptResult(value) {
    return typeof value === "object" && "messages" in value && Array.isArray(value.messages);
}
function isFromPath(value) {
    return typeof value === "object" && "path" in value && typeof value.path === "string";
}
function isEmptyObjectType(schema) {
    return schema instanceof ZodObject && Object.keys(schema.shape).length === 0;
}
