import { toMessagePayload } from "../aigne/message-queue.js";
import { flat } from "../utils/type-utils.js";
import { Agent, } from "./agent.js";
export class UserAgent extends Agent {
    tag = "UserAgent";
    static from(options) {
        return new UserAgent(options);
    }
    constructor(options) {
        super({ ...options, disableEvents: true });
        this._process = options.process;
        this.context = options.context;
        this.activeAgent = options.activeAgent;
    }
    context;
    _process;
    activeAgent;
    subscribeToTopics(context) {
        if (this._process)
            super.subscribeToTopics(context);
    }
    async publishToTopics(output, options) {
        if (this._process)
            super.publishToTopics(output, options);
    }
    invoke = ((input, options = {}) => {
        options.context ??= this.context.newContext({ reset: true });
        return super.invoke(input, options);
    });
    async process(input, options) {
        if (this._process) {
            return this._process(input, options);
        }
        if (this.activeAgent) {
            const [output, agent] = await options.context.invoke(this.activeAgent, input, {
                returnActiveAgent: true,
                streaming: true,
                // Do not create a new context for the nested agent invocation,
                // We are resetting the context in the override invoke method
                newContext: false,
            });
            agent.then((agent) => {
                this.activeAgent = agent;
            });
            return output;
        }
        const publicTopic = typeof this.publishTopic === "function" ? await this.publishTopic(input) : this.publishTopic;
        if (publicTopic?.length) {
            options.context.publish(publicTopic, input, { newContext: false });
            if (this.subscribeTopic) {
                return this.subscribe(this.subscribeTopic).then((res) => res.message);
            }
            return {};
        }
        throw new Error("UserAgent must have a process function or a publishTopic");
    }
    publish = ((topic, payload) => {
        return this.context.publish(topic, toMessagePayload(payload, { role: "user", source: this.name }));
    });
    subscribe = ((...args) => {
        return this.context.subscribe(...args);
    });
    unsubscribe = ((...args) => {
        this.context.unsubscribe(...args);
    });
    get stream() {
        let subscriptions = [];
        return new ReadableStream({
            start: (controller) => {
                const subscribeTopic = flat(this.subscribeTopic);
                subscriptions = subscribeTopic.map((topic) => this.subscribe(topic, (message) => {
                    controller.enqueue({ ...message, topic });
                }));
            },
            cancel: () => {
                for (const unsubscribe of subscriptions) {
                    unsubscribe();
                }
            },
        });
    }
    checkAgentInvokesUsage(_options) {
        // ignore calls usage check for UserAgent
    }
}
