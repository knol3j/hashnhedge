import { Ajv } from "ajv";
import isNetworkError from "is-network-error";
import { z } from "zod";
import { checkArguments } from "../utils/type-utils.js";
import { Agent, agentOptionsSchema, } from "./agent.js";
const CHAT_MODEL_DEFAULT_RETRY_OPTIONS = {
    retries: 3,
    shouldRetry: (error) => error instanceof StructuredOutputError || isNetworkError(error),
};
export class StructuredOutputError extends Error {
}
/**
 * ChatModel is an abstract base class for interacting with Large Language Models (LLMs).
 *
 * This class extends the Agent class and provides a common interface for handling model inputs,
 * outputs, and capabilities. Specific model implementations (like OpenAI, Anthropic, etc.)
 * should inherit from this class and implement their specific functionalities.
 *
 * @example
 * Here's how to implement a custom ChatModel:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model}
 *
 * @example
 * Here's an example showing streaming response with readable stream:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-streaming}
 *
 * @example
 * Here's an example showing streaming response with async generator:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-streaming-async-generator}
 *
 * @example
 * Here's an example with tool calls:
 * {@includeCode ../../test/agents/chat-model.test.ts#example-chat-model-tools}
 */
export class ChatModel extends Agent {
    tag = "ChatModelAgent";
    constructor(options) {
        if (options)
            checkArguments("ChatModel", agentOptionsSchema, options);
        const retryOnError = options?.retryOnError === false
            ? false
            : options?.retryOnError === true
                ? CHAT_MODEL_DEFAULT_RETRY_OPTIONS
                : {
                    ...CHAT_MODEL_DEFAULT_RETRY_OPTIONS,
                    ...options?.retryOnError,
                };
        super({
            ...options,
            inputSchema: chatModelInputSchema,
            outputSchema: chatModelOutputSchema,
            retryOnError,
        });
    }
    get credential() {
        return {};
    }
    /**
     * Indicates whether the model supports parallel tool calls
     *
     * Defaults to true, subclasses can override this property based on
     * specific model capabilities
     */
    supportsParallelToolCalls = true;
    /**
     * Gets the model's supported capabilities
     *
     * Currently returns capabilities including: whether parallel tool calls are supported
     *
     * @returns An object containing model capabilities
     */
    getModelCapabilities() {
        return {
            supportsParallelToolCalls: this.supportsParallelToolCalls,
        };
    }
    validateToolNames(tools) {
        for (const tool of tools ?? []) {
            if (!/^[a-zA-Z0-9_]+$/.test(tool.function.name)) {
                throw new Error(`Tool name "${tool.function.name}" can only contain letters, numbers, and underscores`);
            }
        }
    }
    /**
     * Normalizes tool names to ensure compatibility with language models
     *
     * This method converts tool names to a format that complies with model requirements
     * by replacing hyphens and whitespace characters with underscores. The normalized
     * names are used for tool calls while preserving the original names for reference.
     *
     * @param name - The original tool name to normalize
     * @returns A promise that resolves to the normalized tool name
     */
    async normalizeToolName(name) {
        return name.replaceAll(/[-\s]/g, "_");
    }
    /**
     * Performs preprocessing operations before handling input
     *
     * Primarily checks if token usage exceeds limits, throwing an exception if limits are exceeded
     *
     * @param input Input message
     * @param options Options for invoking the agent
     * @throws Error if token usage exceeds maximum limit
     */
    async preprocess(input, options) {
        super.preprocess(input, options);
        const { limits, usage } = options.context;
        const usedTokens = usage.outputTokens + usage.inputTokens;
        if (limits?.maxTokens && usedTokens >= limits.maxTokens) {
            throw new Error(`Exceeded max tokens ${usedTokens}/${limits.maxTokens}`);
        }
        // Automatically convert tool names to a valid format
        if (input.tools?.length) {
            const toolsMap = {};
            const tools = [];
            for (const originalTool of input.tools) {
                const name = await this.normalizeToolName(originalTool.function.name);
                const tool = {
                    ...originalTool,
                    function: { ...originalTool.function, name },
                };
                tools.push(tool);
                toolsMap[name] = originalTool;
            }
            this.validateToolNames(tools);
            Object.assign(input, { tools });
            Object.defineProperty(input, "_toolsMap", {
                value: toolsMap,
                enumerable: false,
            });
        }
    }
    /**
     * Performs postprocessing operations after handling output
     *
     * Primarily updates token usage statistics in the context
     *
     * @param input Input message
     * @param output Output message
     * @param options Options for invoking the agent
     */
    async postprocess(input, output, options) {
        // Restore original tool names in the output
        if (output.toolCalls?.length) {
            const toolsMap = input._toolsMap;
            if (toolsMap) {
                for (const toolCall of output.toolCalls) {
                    const originalTool = toolsMap[toolCall.function.name];
                    if (!originalTool) {
                        throw new Error(`Tool "${toolCall.function.name}" not found in tools map`);
                    }
                    toolCall.function.name = originalTool.function.name;
                }
            }
        }
        if (input.responseFormat?.type === "json_schema" &&
            // NOTE: Should not validate if there are tool calls
            !output.toolCalls?.length) {
            const ajv = new Ajv();
            if (!ajv.validate(input.responseFormat.jsonSchema.schema, output.json)) {
                throw new StructuredOutputError(`Output JSON does not conform to the provided JSON schema: ${ajv.errorsText()}`);
            }
        }
        super.postprocess(input, output, options);
        const { usage } = output;
        if (usage) {
            options.context.usage.outputTokens += usage.outputTokens;
            options.context.usage.inputTokens += usage.inputTokens;
            if (usage.aigneHubCredits)
                options.context.usage.aigneHubCredits += usage.aigneHubCredits;
        }
    }
}
const chatModelInputMessageSchema = z.object({
    role: z.union([z.literal("system"), z.literal("user"), z.literal("agent"), z.literal("tool")]),
    content: z
        .union([
        z.string(),
        z.array(z.union([
            z.object({ type: z.literal("text"), text: z.string() }),
            z.object({ type: z.literal("image_url"), url: z.string() }),
        ])),
    ])
        .optional(),
    toolCalls: z
        .array(z.object({
        id: z.string(),
        type: z.literal("function"),
        function: z.object({
            name: z.string(),
            arguments: z.record(z.string(), z.unknown()),
        }),
    }))
        .optional(),
    toolCallId: z.string().optional(),
    name: z.string().optional(),
});
const chatModelInputResponseFormatSchema = z.discriminatedUnion("type", [
    z.object({ type: z.literal("text") }),
    z.object({
        type: z.literal("json_schema"),
        jsonSchema: z.object({
            name: z.string(),
            description: z.string().optional(),
            schema: z.record(z.string(), z.unknown()),
            strict: z.boolean().optional(),
        }),
    }),
]);
const chatModelInputToolSchema = z.object({
    type: z.literal("function"),
    function: z.object({
        name: z.string(),
        description: z.string().optional(),
        parameters: z.record(z.string(), z.unknown()),
    }),
});
const chatModelInputToolChoiceSchema = z.union([
    z.literal("auto"),
    z.literal("none"),
    z.literal("required"),
    chatModelInputToolSchema,
]);
const chatModelOptionsSchema = z.object({
    model: z.string().optional(),
    temperature: z.number().optional(),
    topP: z.number().optional(),
    frequencyPenalty: z.number().optional(),
    presencePenalty: z.number().optional(),
    parallelToolCalls: z.boolean().optional().default(true),
});
const chatModelInputSchema = z.object({
    messages: z.array(chatModelInputMessageSchema),
    responseFormat: chatModelInputResponseFormatSchema.optional(),
    tools: z.array(chatModelInputToolSchema).optional(),
    toolChoice: chatModelInputToolChoiceSchema.optional(),
    modelOptions: chatModelOptionsSchema.optional(),
});
const chatModelOutputToolCallSchema = z.object({
    id: z.string(),
    type: z.literal("function"),
    function: z.object({
        name: z.string(),
        arguments: z.record(z.string(), z.unknown()),
    }),
});
export const chatModelOutputUsageSchema = z.object({
    inputTokens: z.number(),
    outputTokens: z.number(),
    aigneHubCredits: z.number().optional(),
});
const chatModelOutputSchema = z.object({
    text: z.string().optional(),
    json: z.record(z.string(), z.unknown()).optional(),
    toolCalls: z.array(chatModelOutputToolCallSchema).optional(),
    usage: chatModelOutputUsageSchema.optional(),
    model: z.string().optional(),
});
