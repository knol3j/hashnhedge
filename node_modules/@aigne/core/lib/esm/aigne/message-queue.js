import { Emitter } from "strict-event-emitter";
import { z } from "zod";
import { checkArguments, flat, isNil } from "../utils/type-utils.js";
/**
 * @hidden
 */
export const UserInputTopic = "UserInputTopic";
/**
 * @hidden
 */
export const UserOutputTopic = "UserOutputTopic";
function isMessagePayload(payload) {
    return (!isNil(payload) &&
        typeof payload === "object" &&
        "role" in payload &&
        typeof payload.role === "string" &&
        ["user", "agent"].includes(payload.role) &&
        "message" in payload &&
        !isNil(payload.message));
}
/**
 * @hidden
 */
export function toMessagePayload(payload, options) {
    if (isMessagePayload(payload)) {
        return { ...payload, ...options };
    }
    return {
        role: options?.role || "user",
        source: options?.source,
        message: payload,
    };
}
/**
 * @hidden
 */
export class MessageQueue {
    events = new Emitter();
    publish(topic, payload) {
        checkArguments("MessageQueue.publish", publishArgsSchema, {
            topic,
            payload,
        });
        for (const t of flat(topic)) {
            this.events.emit(t, payload);
        }
    }
    error(error) {
        this.events.emit("error", error);
    }
    subscribe(topic, listener) {
        checkArguments("MessageQueue.subscribe", subscribeArgsSchema, {
            topic,
            listener,
        });
        if (!listener) {
            return new Promise((resolve, reject) => {
                const unsubscribe1 = once(this.events, topic, (message) => {
                    unsubscribe2();
                    resolve(message);
                });
                const unsubscribe2 = once(this.events, "error", (error) => {
                    unsubscribe1();
                    reject(error);
                });
            });
        }
        return on(this.events, topic, listener);
    }
    unsubscribe(topic, listener) {
        checkArguments("MessageQueue.unsubscribe", unsubscribeArgsSchema, {
            topic,
            listener,
        });
        for (const t of flat(topic)) {
            this.events.off(t, listener);
        }
    }
}
function on(events, event, listener) {
    flat(event).forEach((e) => events.on(e, listener));
    return () => flat(event).forEach((e) => events.off(e, listener));
}
function once(events, event, listener) {
    flat(event).forEach((e) => events.once(e, listener));
    return () => flat(event).forEach((e) => events.off(e, listener));
}
const subscribeArgsSchema = z.object({
    topic: z.union([z.string(), z.array(z.string())]),
    listener: z.custom().optional(),
});
const unsubscribeArgsSchema = z.object({
    topic: z.union([z.string(), z.array(z.string())]),
    listener: z.custom(),
});
const publishArgsSchema = z.object({
    topic: z.union([z.string(), z.array(z.string())]),
    payload: z.object({
        role: z.union([z.literal("user"), z.literal("agent")]),
        source: z.string().optional(),
        message: z.union([z.string(), z.record(z.string(), z.unknown())]),
        context: z.any(),
    }),
});
