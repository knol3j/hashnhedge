import { context, SpanStatusCode, trace } from "@opentelemetry/api";
import equal from "fast-deep-equal";
import { Emitter } from "strict-event-emitter";
import { v7 } from "uuid";
import { z } from "zod";
import { isAgentResponseDelta, isEmptyChunk, } from "../agents/agent.js";
import { isTransferAgentOutput, transferAgentOutputKey, } from "../agents/types.js";
import { UserAgent } from "../agents/user-agent.js";
import { AgentResponseProgressStream } from "../utils/event-stream.js";
import { logger } from "../utils/logger.js";
import { promiseWithResolvers } from "../utils/promise.js";
import { agentResponseStreamToObject, asyncGeneratorToReadableStream, mergeReadableStreams, onAgentResponseStreamEnd, } from "../utils/stream-utils.js";
import { checkArguments, flat, isEmpty, isNil, omit, } from "../utils/type-utils.js";
import { MessageQueue, toMessagePayload, } from "./message-queue.js";
import { newEmptyContextUsage } from "./usage.js";
/**
 * @hidden
 */
export class AIGNEContext {
    constructor(parent, { reset } = {}) {
        const tracer = parent?.observer?.tracer;
        if (parent instanceof AIGNEContext && !reset) {
            this.internal = parent.internal;
            this.parentId = parent.id;
            this.rootId = parent.rootId;
            if (parent.span) {
                const parentContext = trace.setSpan(context.active(), parent.span);
                this.span = tracer?.startSpan("childAIGNEContext", undefined, parentContext);
            }
            else {
                if (parent.observer && !process.env.AIGNE_OBSERVABILITY_DISABLED) {
                    throw new Error("parent span is not set");
                }
            }
        }
        else {
            this.span = tracer?.startSpan("AIGNEContext");
            this.internal = new AIGNEContextShared(parent instanceof AIGNEContext ? parent.internal : parent);
            // 修改了 rootId 是否会之前的有影响？，之前为 this.id
            this.rootId = this.span?.spanContext?.().traceId ?? v7();
        }
        this.id = this.span?.spanContext()?.spanId ?? v7();
    }
    id;
    parentId;
    rootId;
    span;
    internal;
    get messageQueue() {
        return this.internal.messageQueue;
    }
    get model() {
        return this.internal.model;
    }
    get imageModel() {
        return this.internal.imageModel;
    }
    get skills() {
        return this.internal.skills;
    }
    get agents() {
        return this.internal.agents;
    }
    get observer() {
        return this.internal.observer;
    }
    get limits() {
        return this.internal.limits;
    }
    get status() {
        return this.internal.status;
    }
    get usage() {
        return this.internal.usage;
    }
    get userContext() {
        return this.internal.userContext;
    }
    set userContext(userContext) {
        this.internal.userContext = userContext;
    }
    get memories() {
        return this.internal.memories;
    }
    set memories(memories) {
        this.internal.memories = memories;
    }
    get hooks() {
        return this.internal.hooks;
    }
    set hooks(hooks) {
        this.internal.hooks = hooks;
    }
    newContext({ reset } = {}) {
        return new AIGNEContext(this, { reset });
    }
    invoke = ((agent, message, options) => {
        checkArguments("AIGNEContext.invoke", aigneContextInvokeArgsSchema, {
            agent,
            message,
            options,
        });
        this.processOptions(options);
        if (isNil(message)) {
            return UserAgent.from({
                context: this,
                activeAgent: agent,
            });
        }
        const newContext = options?.newContext === false ? this : this.newContext();
        return Promise.resolve(newContext.internal.invoke(agent, message, newContext, options)).then(async (response) => {
            if (!options?.streaming) {
                let { __activeAgent__: activeAgent, ...output } = await agentResponseStreamToObject(response);
                output = await this.onInvocationResult(output, options);
                if (options?.returnActiveAgent) {
                    return [output, activeAgent];
                }
                return output;
            }
            const activeAgentPromise = promiseWithResolvers();
            const stream = onAgentResponseStreamEnd(asyncGeneratorToReadableStream(response), {
                onChunk(chunk) {
                    if (isAgentResponseDelta(chunk) && chunk.delta.json) {
                        return {
                            ...chunk,
                            delta: {
                                ...chunk.delta,
                                json: omit(chunk.delta.json, "__activeAgent__"),
                            },
                        };
                    }
                },
                onResult: async (output) => {
                    activeAgentPromise.resolve(output.__activeAgent__);
                    return await this.onInvocationResult(output, options);
                },
            });
            const finalStream = !options.returnProgressChunks
                ? stream
                : mergeReadableStreams(stream, new AgentResponseProgressStream(newContext));
            if (options.returnActiveAgent) {
                return [finalStream, activeAgentPromise.promise];
            }
            return finalStream;
        });
    });
    async onInvocationResult(output, options) {
        if (!options?.returnMetadata) {
            return output;
        }
        return {
            ...output,
            $meta: {
                ...output.$meta,
                usage: this.usage,
            },
        };
    }
    processOptions(options) {
        if (options?.userContext) {
            Object.assign(this.userContext, options.userContext);
            options.userContext = undefined;
        }
        if (options?.memories?.length) {
            this.memories.push(...options.memories);
            options.memories = undefined;
        }
        if (options?.hooks) {
            this.hooks.push(...flat(options.hooks));
            options.hooks = undefined;
        }
    }
    publish = ((topic, payload, options) => {
        this.processOptions(options);
        const newContext = options?.newContext === false ? this : this.newContext();
        return this.internal.messageQueue.publish(topic, {
            ...toMessagePayload(payload),
            context: newContext,
        });
    });
    subscribe = ((...args) => {
        return this.internal.messageQueue.subscribe(...args);
    });
    unsubscribe = ((...args) => {
        return this.internal.messageQueue.unsubscribe(...args);
    });
    emit(eventName, ...args) {
        const b = {
            ...args[0],
            contextId: this.id,
            parentContextId: this.parentId,
            timestamp: Date.now(),
        };
        const newArgs = [b, ...args.slice(1)];
        this.trace(eventName, args, b);
        return this.internal.events.emit(eventName, ...newArgs);
    }
    async trace(eventName, args, b) {
        const span = this.span;
        if (!span)
            return;
        try {
            switch (eventName) {
                case "agentStarted": {
                    const { agent, input } = args[0];
                    span.updateName(agent.name);
                    span.setAttribute("custom.trace_id", this.rootId);
                    span.setAttribute("custom.span_id", this.id);
                    if (this.parentId) {
                        span.setAttribute("custom.parent_id", this.parentId);
                    }
                    span.setAttribute("custom.started_at", b.timestamp);
                    span.setAttribute("input", JSON.stringify(input));
                    span.setAttribute("agentTag", agent.tag ?? "UnknownAgent");
                    try {
                        span.setAttribute("userContext", JSON.stringify(this.userContext));
                    }
                    catch (_e) {
                        logger.error("parse userContext error", _e.message);
                        span.setAttribute("userContext", JSON.stringify({}));
                    }
                    try {
                        span.setAttribute("memories", JSON.stringify(this.memories));
                    }
                    catch (_e) {
                        logger.error("parse memories error", _e.message);
                        span.setAttribute("memories", JSON.stringify([]));
                    }
                    await this.observer?.flush(span);
                    break;
                }
                case "agentSucceed": {
                    const { output } = args[0];
                    try {
                        span.setAttribute("output", JSON.stringify(output));
                    }
                    catch (_e) {
                        logger.error("parse output error", _e.message);
                        span.setAttribute("output", JSON.stringify({}));
                    }
                    span.setStatus({ code: SpanStatusCode.OK });
                    span.end();
                    break;
                }
                case "agentFailed": {
                    const { error } = args[0];
                    span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
                    span.end();
                    break;
                }
            }
        }
        catch (err) {
            logger.error("AIGNEContext.trace observer error", { eventName, error: err });
        }
    }
    on(eventName, listener) {
        this.internal.events.on(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        this.internal.events.once(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        this.internal.events.off(eventName, listener);
        return this;
    }
}
class AIGNEContextShared {
    parent;
    constructor(parent) {
        this.parent = parent;
        this.messageQueue = this.parent?.messageQueue ?? new MessageQueue();
        this.events = this.parent?.events ?? new Emitter();
    }
    messageQueue;
    events;
    get model() {
        return this.parent?.model;
    }
    get imageModel() {
        return this.parent?.imageModel;
    }
    get skills() {
        return this.parent?.skills;
    }
    get agents() {
        return this.parent?.agents ?? [];
    }
    get observer() {
        return this.parent?.observer;
    }
    get limits() {
        return this.parent?.limits;
    }
    usage = newEmptyContextUsage();
    userContext = {};
    memories = [];
    hooks = [];
    abortController = new AbortController();
    timer;
    initTimeout() {
        if (this.timer)
            return;
        const timeout = this.limits?.timeout;
        if (timeout) {
            this.timer = setTimeout(() => {
                this.abortController.abort();
            }, timeout);
        }
    }
    get status() {
        return this.abortController.signal.aborted ? "timeout" : "normal";
    }
    invoke(agent, input, context, options) {
        this.initTimeout();
        return withAbortSignal(this.abortController.signal, new Error("AIGNEContext is timeout"), () => this.invokeAgent(agent, input, context, options));
    }
    async *invokeAgent(agent, input, context, options = {}) {
        const startedAt = Date.now();
        try {
            let activeAgent = agent;
            for (;;) {
                const result = {};
                if (options?.sourceAgent && activeAgent !== options.sourceAgent) {
                    for (const { onHandoff } of flat(options.hooks, options.sourceAgent.hooks)) {
                        if (!onHandoff)
                            continue;
                        await (typeof onHandoff === "function"
                            ? onHandoff({
                                context,
                                source: options.sourceAgent,
                                target: activeAgent,
                                input,
                            })
                            : context.invoke(onHandoff, {
                                source: options.sourceAgent,
                                target: activeAgent,
                                input,
                            }));
                    }
                }
                const stream = await activeAgent.invoke(input, {
                    hooks: options.hooks,
                    context,
                    streaming: true,
                });
                for await (const value of stream) {
                    if (isAgentResponseDelta(value)) {
                        if (value.delta.json) {
                            value.delta.json = omitExistsProperties(result, value.delta.json);
                            Object.assign(result, value.delta.json);
                        }
                        delete value.delta.json?.[transferAgentOutputKey];
                    }
                    if (isEmptyChunk(value))
                        continue;
                    yield value;
                }
                if (!options?.disableTransfer) {
                    const transferToAgent = isTransferAgentOutput(result)
                        ? result[transferAgentOutputKey].agent
                        : undefined;
                    if (transferToAgent) {
                        activeAgent = transferToAgent;
                        continue;
                    }
                }
                break;
            }
            yield {
                delta: {
                    json: { __activeAgent__: activeAgent },
                },
            };
        }
        finally {
            const endedAt = Date.now();
            const duration = endedAt - startedAt;
            this.usage.duration += duration;
        }
    }
}
function omitExistsProperties(result, { ...delta }) {
    for (const [key, val] of Object.entries(delta)) {
        if (equal(result[key], val))
            delete delta[key];
    }
    return isEmpty(delta) ? undefined : delta;
}
async function* withAbortSignal(signal, error, fn) {
    const iterator = fn();
    const timeoutPromise = promiseWithResolvers();
    const listener = () => {
        timeoutPromise.reject(error);
    };
    signal.addEventListener("abort", listener);
    try {
        for (;;) {
            const next = await Promise.race([iterator.next(), timeoutPromise.promise]);
            if (next.done)
                break;
            yield next.value;
        }
    }
    finally {
        signal.removeEventListener("abort", listener);
    }
}
const aigneContextInvokeArgsSchema = z.object({
    agent: z.union([z.custom(), z.custom()]),
    message: z.union([z.record(z.string(), z.unknown()), z.string()]).optional(),
    options: z.object({ returnActiveAgent: z.boolean().optional() }).optional(),
});
