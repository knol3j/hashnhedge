import { AIGNEObserver } from "@aigne/observability-api";
import { z } from "zod";
import { load } from "../loader/index.js";
import { checkArguments, createAccessorArray } from "../utils/type-utils.js";
import { AIGNEContext } from "./context.js";
import { MessageQueue, } from "./message-queue.js";
/**
 * AIGNE is a class that orchestrates multiple agents to build complex AI applications.
 * It serves as the central coordination point for agent interactions, message passing, and execution flow.
 *
 * @example
 * Here's a simple example of how to use AIGNE:
 * {@includeCode ../../test/aigne/aigne.test.ts#example-simple}
 *
 * @example
 * Here's an example of how to use AIGNE with streaming response:
 * {@includeCode ../../test/aigne/aigne.test.ts#example-streaming}
 */
export class AIGNE {
    /**
     * Loads an AIGNE instance from a directory containing an aigne.yaml file and agent definitions.
     * This static method provides a convenient way to initialize an AIGNE system from configuration files.
     *
     * @param path - Path to the directory containing the aigne.yaml file.
     * @param options - Options to override the loaded configuration.
     * @returns A fully initialized AIGNE instance with configured agents and skills.
     */
    static async load(path, options = {}) {
        const { agents = [], skills = [], model, imageModel, ...aigne } = await load(path, options);
        return new AIGNE({
            ...aigne,
            ...options,
            model,
            imageModel,
            agents: agents.concat(options?.agents ?? []),
            skills: skills.concat(options?.skills ?? []),
        });
    }
    /**
     * Creates a new AIGNE instance with the specified options.
     *
     * @param options - Configuration options for the AIGNE instance including name, description, model, and agents.
     */
    constructor(options) {
        if (options)
            checkArguments("AIGNE", aigneOptionsSchema, options);
        this.rootDir = options?.rootDir;
        this.name = options?.name;
        this.description = options?.description;
        this.model = options?.model;
        this.imageModel = options?.imageModel;
        this.limits = options?.limits;
        this.observer =
            process.env.AIGNE_OBSERVABILITY_DISABLED === "true"
                ? undefined
                : (options?.observer ?? new AIGNEObserver());
        if (options?.skills?.length)
            this.skills.push(...options.skills);
        if (options?.agents?.length)
            this.addAgent(...options.agents);
        if (options?.mcpServer?.agents?.length)
            this.mcpServer.agents.push(...options.mcpServer.agents);
        if (options?.cli?.agents?.length)
            this.cli.agents.push(...options.cli.agents);
        if (options?.cli?.chat)
            this.cli.chat = options.cli.chat;
        this.observer?.serve();
        this.initProcessExitHandler();
    }
    /**
     * Optional root directory for this AIGNE instance.
     */
    rootDir;
    /**
     * Optional name identifier for this AIGNE instance.
     */
    name;
    /**
     * Optional description of this AIGNE instance's purpose or functionality.
     */
    description;
    /**
     * Global model to use for all agents that don't specify their own model.
     */
    model;
    /**
     * Optional image model to use for image processing tasks.
     */
    imageModel;
    /**
     * Usage limits applied to this AIGNE instance's execution.
     */
    limits;
    /**
     * Message queue for handling inter-agent communication.
     *
     * @hidden
     */
    messageQueue = new MessageQueue();
    /**
     * Collection of skill agents available to this AIGNE instance.
     * Provides indexed access by skill name.
     */
    skills = createAccessorArray([], (arr, name) => arr.find((i) => i.name === name));
    /**
     * Collection of primary agents managed by this AIGNE instance.
     * Provides indexed access by agent name.
     */
    agents = createAccessorArray([], (arr, name) => arr.find((i) => i.name === name));
    mcpServer = {
        agents: createAccessorArray([], (arr, name) => arr.find((i) => i.name === name)),
    };
    cli = {
        chat: undefined,
        agents: createAccessorArray([], (arr, name) => arr.find((i) => i.name === name)),
    };
    /**
     * Observer for the AIGNE instance.
     */
    observer;
    /**
     * Adds one or more agents to this AIGNE instance.
     * Each agent is attached to this AIGNE instance, allowing it to access the AIGNE's resources.
     *
     * @param agents - One or more Agent instances to add to this AIGNE.
     */
    addAgent(...agents) {
        checkArguments("AIGNE.addAgent", aigneAddAgentArgsSchema, agents);
        for (const agent of agents) {
            this.agents.push(agent);
            agent.attach(this);
        }
    }
    /**
     * Creates a new execution context for this AIGNE instance.
     * Contexts isolate state for different flows or conversations.
     *
     * @returns A new AIGNEContext instance bound to this AIGNE.
     */
    newContext(options) {
        const context = new AIGNEContext(this);
        if (options?.userContext)
            context.userContext = options.userContext;
        if (options?.memories)
            context.memories = options.memories;
        return context;
    }
    invoke(agent, message, options) {
        this.observer?.serve();
        const context = new AIGNEContext(this);
        return context.invoke(agent, message, { ...options, newContext: false });
    }
    /**
     * Publishes a message to the message queue for inter-agent communication.
     * This method broadcasts a message to all subscribers of the specified topic(s).
     * It creates a new context internally and delegates to the context's publish method.
     *
     * @param topic - The topic or array of topics to publish the message to
     * @param payload - The message payload to be delivered to subscribers
     * @param options - Optional configuration parameters for the publish operation
     *
     * @example
     * Here's an example of how to publish a message:
     * {@includeCode ../../test/aigne/aigne.test.ts#example-publish-message}
     */
    publish(topic, payload, options) {
        this.observer?.serve();
        return new AIGNEContext(this).publish(topic, payload, options);
    }
    subscribe(topic, listener) {
        return this.messageQueue.subscribe(topic, listener);
    }
    /**
     * Unsubscribes a listener from a specific topic in the message queue.
     * This method stops a previously registered listener from receiving further messages.
     * It should be called when message processing is complete or when the component is no longer interested
     * in messages published to the specified topic.
     *
     * @param topic - The topic to unsubscribe from
     * @param listener - The listener function that was previously subscribed to the topic
     *
     * @example
     * {@includeCode ../../test/aigne/aigne.test.ts#example-subscribe-topic}
     */
    unsubscribe(topic, listener) {
        this.messageQueue.unsubscribe(topic, listener);
    }
    /**
     * Gracefully shuts down the AIGNE instance and all its agents and skills.
     * This ensures proper cleanup of resources before termination.
     *
     * @returns A promise that resolves when shutdown is complete.
     *
     * @example
     * Here's an example of shutdown an AIGNE instance:
     * {@includeCode ../../test/aigne/aigne.test.ts#example-shutdown}
     */
    async shutdown() {
        for (const tool of this.skills) {
            await tool.shutdown();
        }
        for (const agent of this.agents) {
            await agent.shutdown();
        }
    }
    /**
     * Asynchronous dispose method for the AIGNE instance.
     *
     * @example
     * Here's an example of using async dispose:
     * {@includeCode ../../test/aigne/aigne.test.ts#example-shutdown-using}
     */
    async [Symbol.asyncDispose]() {
        await this.shutdown();
    }
    /**
     * Initializes handlers for process exit events to ensure clean shutdown.
     * This registers handlers for SIGINT and exit events to properly terminate all agents.
     */
    initProcessExitHandler() {
        const shutdownAndExit = () => this.shutdown().finally(() => process.exit(0));
        process.on("SIGINT", shutdownAndExit);
        process.on("exit", shutdownAndExit);
    }
}
const aigneOptionsSchema = z.object({
    model: z.custom().optional(),
    imageModel: z.custom().optional(),
    skills: z.array(z.custom()).optional(),
    agents: z.array(z.custom()).optional(),
    observer: z.custom().optional(),
});
const aigneAddAgentArgsSchema = z.array(z.custom());
