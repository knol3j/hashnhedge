import { z } from "zod";
export function isNil(value) {
    return value === null || value === undefined;
}
export function isRecord(value) {
    return !!value && typeof value === "object" && !Array.isArray(value);
}
export function isEmpty(obj) {
    if (isNil(obj))
        return true;
    if (typeof obj === "string" || Array.isArray(obj))
        return obj.length === 0;
    if (typeof obj === "object")
        return Object.keys(obj).length === 0;
    return false;
}
export function isNonNullable(value) {
    return !isNil(value);
}
export function isNotEmpty(arr) {
    return arr.length > 0;
}
export function duplicates(arr, key = (item) => item) {
    const seen = new Set();
    const duplicates = new Set();
    for (const item of arr) {
        const k = key(item);
        if (seen.has(k)) {
            duplicates.add(item);
        }
        else {
            seen.add(k);
        }
    }
    return Array.from(duplicates);
}
export function remove(arr, remove) {
    const removed = [];
    for (let i = 0; i < arr.length; i++) {
        // biome-ignore lint/style/noNonNullAssertion: false positive
        const item = arr[i];
        if ((Array.isArray(remove) && remove.includes(item)) ||
            (typeof remove === "function" && remove(item))) {
            removed.push(...arr.splice(i, 1));
            i--;
        }
    }
    return removed;
}
export function unique(arr, key = (item) => item) {
    const seen = new Set();
    return arr.filter((item) => {
        const k = key(item);
        if (seen.has(k)) {
            return false;
        }
        seen.add(k);
        return true;
    });
}
export function pick(obj, ...keys) {
    const flattenedKeys = new Set(keys.flat());
    return Object.fromEntries(Object.entries(obj).filter(([key]) => flattenedKeys.has(key)));
}
export function omit(obj, ...keys) {
    const flattenedKeys = new Set(keys.flat());
    return Object.fromEntries(Object.entries(obj).filter(([key]) => !flattenedKeys.has(key)));
}
export function omitDeep(obj, ...keys) {
    if (Array.isArray(obj)) {
        return obj.map((item) => omitDeep(item, ...keys));
    }
    if (isRecord(obj)) {
        const flattenedKeys = new Set(keys.flat());
        return Object.fromEntries(Object.entries(obj)
            .filter(([key]) => !flattenedKeys.has(key))
            .map(([key, value]) => [key, omitDeep(value, ...keys)]));
    }
    return obj;
}
export function omitBy(obj, predicate) {
    return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {
        const k = key;
        return !predicate(value, k);
    }));
}
export function flat(...value) {
    return value.flat().filter(isNonNullable);
}
export function createAccessorArray(array, accessor) {
    return new Proxy(array, {
        get: (t, p, r) => Reflect.get(t, p, r) ?? accessor(array, p),
    });
}
export function checkArguments(prefix, schema, args) {
    try {
        return schema.parse(args, {
            errorMap: (issue, ctx) => {
                if (issue.code === "invalid_union") {
                    // handle all issues that are not invalid_type
                    const otherQuestions = issue.unionErrors
                        .map(({ issues: [issue] }) => {
                        if (issue && issue.code !== "invalid_type") {
                            return issue.message || z.defaultErrorMap(issue, ctx).message;
                        }
                    })
                        .filter(isNonNullable);
                    if (otherQuestions.length) {
                        return { message: otherQuestions.join(", ") };
                    }
                    // handle invalid_type issues
                    const expected = issue.unionErrors
                        .map(({ issues: [issue] }) => {
                        if (issue?.code === "invalid_type") {
                            return issue;
                        }
                    })
                        .filter(isNonNullable);
                    if (expected.length) {
                        return {
                            message: `Expected ${expected.map((i) => i.expected).join(" or ")}, received ${expected[0]?.received}`,
                        };
                    }
                }
                return { message: ctx.defaultError };
            },
        });
    }
    catch (error) {
        if (error instanceof z.ZodError) {
            const message = error.issues.map((i) => `${i.path}: ${i.message}`).join(", ");
            throw new Error(`${prefix} check arguments error: ${message}`);
        }
        throw error;
    }
}
export function tryOrThrow(fn, error) {
    const createError = (e) => {
        return typeof error === "function"
            ? error(e)
            : typeof error === "string"
                ? new Error(error)
                : error;
    };
    try {
        const result = fn();
        if (result instanceof Promise) {
            return result.catch((e) => {
                const error = createError(e);
                if (error)
                    throw error;
            });
        }
        return result;
    }
    catch (e) {
        const error = createError(e);
        if (error)
            throw error;
    }
}
