import { jsonSchemaToZod } from "@aigne/json-schema-to-zod";
import { nodejs } from "@aigne/platform-helpers/nodejs/index.js";
import { parse } from "yaml";
import { z } from "zod";
import { AIAgentToolChoice } from "../agents/ai-agent.js";
import { ProcessMode } from "../agents/team-agent.js";
import { tryOrThrow } from "../utils/type-utils.js";
import { camelizeSchema, defaultInputSchema, inputOutputSchema, optionalize } from "./schema.js";
export async function parseAgentFile(path, data) {
    const agentSchema = z.lazy(() => {
        const nestAgentSchema = z.lazy(() => z.union([
            agentSchema,
            z.string(),
            camelizeSchema(z.object({
                url: z.string(),
                defaultInput: optionalize(defaultInputSchema),
                hooks: optionalize(z.union([hooksSchema, z.array(hooksSchema)])),
            })),
        ]));
        const hooksSchema = camelizeSchema(z.object({
            priority: optionalize(z.union([z.literal("low"), z.literal("medium"), z.literal("high")])),
            onStart: optionalize(nestAgentSchema),
            onSuccess: optionalize(nestAgentSchema),
            onError: optionalize(nestAgentSchema),
            onEnd: optionalize(nestAgentSchema),
            onSkillStart: optionalize(nestAgentSchema),
            onSkillEnd: optionalize(nestAgentSchema),
            onHandoff: optionalize(nestAgentSchema),
        }));
        const baseAgentSchema = z.object({
            name: optionalize(z.string()),
            alias: optionalize(z.array(z.string())),
            description: optionalize(z.string()),
            taskTitle: optionalize(z.string()),
            taskRenderMode: optionalize(z.union([z.literal("hide"), z.literal("collapse")])),
            inputSchema: optionalize(inputOutputSchema({ path })).transform((v) => v ? jsonSchemaToZod(v) : undefined),
            defaultInput: optionalize(defaultInputSchema),
            outputSchema: optionalize(inputOutputSchema({ path })).transform((v) => v ? jsonSchemaToZod(v) : undefined),
            hooks: optionalize(z.union([hooksSchema, z.array(hooksSchema)])),
            skills: optionalize(z.array(nestAgentSchema)),
            memory: optionalize(z.union([
                z.boolean(),
                camelizeSchema(z.object({
                    provider: z.string(),
                    subscribeTopic: optionalize(z.array(z.string())),
                })),
            ])),
        });
        const instructionsSchema = z
            .union([
            z.string(),
            z.object({
                url: z.string(),
            }),
        ])
            .transform((v) => typeof v === "string"
            ? { content: v, path }
            : Promise.resolve(nodejs.path.join(nodejs.path.dirname(path), v.url)).then((path) => nodejs.fs.readFile(path, "utf8").then((content) => ({ content, path }))));
        return camelizeSchema(z.discriminatedUnion("type", [
            z
                .object({
                type: z.literal("ai"),
                instructions: optionalize(instructionsSchema),
                inputKey: optionalize(z.string()),
                outputKey: optionalize(z.string()),
                toolChoice: optionalize(z.nativeEnum(AIAgentToolChoice)),
            })
                .extend(baseAgentSchema.shape),
            z
                .object({
                type: z.literal("image"),
                instructions: instructionsSchema,
                modelOptions: optionalize(camelizeSchema(z.record(z.any()))),
            })
                .extend(baseAgentSchema.shape),
            z
                .object({
                type: z.literal("mcp"),
                url: optionalize(z.string()),
                command: optionalize(z.string()),
                args: optionalize(z.array(z.string())),
            })
                .extend(baseAgentSchema.shape),
            z
                .object({
                type: z.literal("team"),
                mode: optionalize(z.nativeEnum(ProcessMode)),
                iterateOn: optionalize(z.string()),
                concurrency: optionalize(z.number().int().min(1)),
                iterateWithPreviousOutput: optionalize(z.boolean()),
                includeAllStepsOutput: optionalize(z.boolean()),
                reflection: camelizeSchema(optionalize(z.object({
                    reviewer: nestAgentSchema,
                    isApproved: z.string(),
                    maxIterations: optionalize(z.number().int().min(1)),
                    returnLastOnMaxIterations: optionalize(z.boolean()),
                }))),
            })
                .extend(baseAgentSchema.shape),
            z
                .object({
                type: z.literal("transform"),
                jsonata: z.string(),
            })
                .extend(baseAgentSchema.shape),
            z
                .object({
                type: z.literal("function"),
                process: z.custom(),
            })
                .extend(baseAgentSchema.shape),
        ]));
    });
    return agentSchema.parseAsync(data);
}
export async function loadAgentFromYamlFile(path) {
    const raw = await tryOrThrow(() => nodejs.fs.readFile(path, "utf8"), (error) => new Error(`Failed to load agent definition from ${path}: ${error.message}`));
    const json = tryOrThrow(() => parse(raw), (error) => new Error(`Failed to parse agent definition from ${path}: ${error.message}`));
    const agent = await tryOrThrow(async () => await parseAgentFile(path, {
        ...json,
        type: json.type ?? "ai",
        skills: json.skills ?? json.tools,
    }), (error) => new Error(`Failed to validate agent definition from ${path}: ${error.message}`));
    return agent;
}
