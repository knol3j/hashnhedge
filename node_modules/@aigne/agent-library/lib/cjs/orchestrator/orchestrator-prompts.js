"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SYNTHESIZE_STEP_PROMPT_TEMPLATE = exports.TASK_PROMPT_TEMPLATE = exports.FULL_PLAN_PROMPT_TEMPLATE = exports.SYNTHESIZE_PLAN_USER_PROMPT_TEMPLATE = void 0;
exports.getFullPlanSchema = getFullPlanSchema;
const json_schema_js_1 = require("@aigne/core/utils/json-schema.js");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const zod_1 = require("zod");
/**
 * @hidden
 */
exports.SYNTHESIZE_PLAN_USER_PROMPT_TEMPLATE = `\
Synthesize the results of executing all steps in the plan into a cohesive result
`;
/**
 * @hidden
 */
function getFullPlanSchema(agents) {
    const agentNames = agents.map((i) => i.name);
    if (new Set(agentNames).size !== agentNames.length) {
        const dup = (0, type_utils_js_1.duplicates)(agentNames);
        throw new Error(`Duplicate agent names found in orchestrator: ${dup.join(",")}`);
    }
    const TaskSchema = zod_1.z.object({
        description: zod_1.z.string().describe("Detailed description of the task"),
        agent: zod_1.z
            .union((0, json_schema_js_1.ensureZodUnionArray)(agents.map((i) => zod_1.z.literal(i.name))))
            .describe("Name of the agent to execute the task"),
    });
    const StepSchema = zod_1.z.object({
        description: zod_1.z.string().describe("Detailed description of the step"),
        tasks: zod_1.z.array(TaskSchema).describe("Tasks that can run in parallel in this step"),
    });
    return zod_1.z.object({
        steps: zod_1.z.array(StepSchema).describe("All sequential steps in the plan"),
        isComplete: zod_1.z.boolean().describe("Whether the previous plan results achieve the objective"),
    });
}
/**
 * @hidden
 */
exports.FULL_PLAN_PROMPT_TEMPLATE = `You are tasked with orchestrating a plan to complete an objective.
You can analyze results from the previous steps already executed to decide if the objective is complete.
Your plan must be structured in sequential steps, with each step containing independent parallel subtasks.

<objective>
{{objective}}
</objective>

<steps_completed>
{% for step in steps %}
- Step: {{step.description}}
  Result: {{result}}
{% endfor %}
</steps_completed>

<previous_plan_status>
{{plan.status}}
</previous_plan_status>

<previous_plan_result>
{{plan.result}}
</previous_plan_result>

You have access to the following Agents(which are collections of tools/functions):

<agents>
{% for agent in agents %}
- Agent: {{agent.name}}
  Description: {{agent.description}}
  Functions:
    {% for tool in tools %}
    - Tool: {{tool.name}}
      Description: {{tool.description}}
    {% endfor %}
{% endfor %}
</agents>

- If the previous plan results achieve the objective, return isComplete=true.
- Otherwise, generate remaining steps needed.
- Generate a plan with all remaining steps needed.
- Steps are sequential, but each Step can have parallel subtasks.
- For each Step, specify a description of the step and independent subtasks that can run in parallel.
- For each subtask specify:
    1. Clear description of the task that an LLM can execute
    2. Name of 1 Agent to use for the task`;
/**
 * @hidden
 */
exports.TASK_PROMPT_TEMPLATE = `\
You are part of a larger workflow to achieve the step then the objective:

<objective>
{{objective}}
</objective>

<step>
{{step.description}}
</step>

Your job is to accomplish only the following task:

<task>
{{task.description}}
</task>

Results so far that may provide helpful context:

<steps_completed>
{% for step in steps %}
- Step: {{step.description}}
  Result: {{step.result}}
{% endfor %}
</steps_completed>
`;
/**
 * @hidden
 */
exports.SYNTHESIZE_STEP_PROMPT_TEMPLATE = `\
Synthesize the results of these parallel tasks into a cohesive result

<objective>
{{objective}}
</objective>

<step>
{{step.description}}
</step>

<tasks>
{% for task in tasks %}
- Task: {{task.description}}
  Result: {{task.result}}
{% endfor %}
</tasks>
`;
