"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrchestratorAgent = void 0;
const core_1 = require("@aigne/core");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const fastq_1 = __importDefault(require("fastq"));
const zod_1 = require("zod");
const orchestrator_prompts_js_1 = require("./orchestrator-prompts.js");
/**
 * Default maximum number of iterations to prevent infinite loops
 */
const DEFAULT_MAX_ITERATIONS = 30;
/**
 * Default number of concurrent tasks
 */
const DEFAULT_TASK_CONCURRENCY = 5;
/**
 * Re-export orchestrator prompt templates and related types
 */
__exportStar(require("./orchestrator-prompts.js"), exports);
/**
 * Orchestrator Agent Class
 *
 * This Agent is responsible for:
 * 1. Generating an execution plan based on the objective
 * 2. Breaking down the plan into steps and tasks
 * 3. Coordinating the execution of steps and tasks
 * 4. Synthesizing the final result
 *
 * Workflow:
 * - Receives input objective
 * - Uses planner to create execution plan
 * - Executes tasks and steps according to the plan
 * - Synthesizes final result through completer
 */
class OrchestratorAgent extends core_1.Agent {
    tag = "OrchestratorAgent";
    /**
     * Factory method to create an OrchestratorAgent instance
     * @param options - Configuration options for the Orchestrator Agent
     * @returns A new OrchestratorAgent instance
     */
    static from(options) {
        return new OrchestratorAgent(options);
    }
    /**
     * Creates an OrchestratorAgent instance
     * @param options - Configuration options for the Orchestrator Agent
     */
    constructor(options) {
        (0, type_utils_js_1.checkArguments)("OrchestratorAgent", orchestratorAgentOptionsSchema, options);
        super({ ...options });
        this.maxIterations = options.maxIterations;
        this.tasksConcurrency = options.tasksConcurrency;
        this.inputKey = options.inputKey;
        this.planner = new core_1.AIAgent({
            name: "llm_orchestration_planner",
            instructions: orchestrator_prompts_js_1.FULL_PLAN_PROMPT_TEMPLATE,
            outputSchema: () => (0, orchestrator_prompts_js_1.getFullPlanSchema)(this.skills),
        });
        this.completer = new core_1.AIAgent({
            name: "llm_orchestration_completer",
            instructions: orchestrator_prompts_js_1.FULL_PLAN_PROMPT_TEMPLATE,
            outputSchema: this.outputSchema,
        });
    }
    planner;
    completer;
    inputKey;
    /**
     * Maximum number of iterations
     * Prevents infinite execution loops
     */
    maxIterations;
    /**
     * Number of concurrent tasks
     * Controls how many tasks can be executed simultaneously
     */
    tasksConcurrency;
    /**
     * Process input and execute the orchestrator workflow
     *
     * Workflow:
     * 1. Extract the objective
     * 2. Loop until plan completion or maximum iterations:
     *    a. Generate/update execution plan
     *    b. If plan is complete, synthesize result
     *    c. Otherwise, execute steps in the plan
     *
     * @param input - Input message containing the objective
     * @param options - Agent invocation options
     * @returns Processing result
     */
    async process(input, options) {
        const { model } = options.context;
        if (!model)
            throw new Error("model is required to run OrchestratorAgent");
        const objective = input[this.inputKey];
        if (typeof objective !== "string")
            throw new Error("Objective is required to run OrchestratorAgent");
        const result = {
            objective,
            steps: [],
        };
        let iterations = 0;
        const maxIterations = this.maxIterations ?? DEFAULT_MAX_ITERATIONS;
        while (iterations++ < maxIterations) {
            const plan = await this.getFullPlan(result, options.context);
            result.plan = plan;
            if (plan.isComplete) {
                return this.synthesizePlanResult(result, options.context);
            }
            for (const step of plan.steps) {
                const stepResult = await this.executeStep(result, step, options.context);
                result.steps.push(stepResult);
            }
        }
        throw new Error(`Max iterations reached: ${maxIterations}`);
    }
    getFullPlanInput(planResult) {
        return {
            objective: planResult.objective,
            steps: planResult.steps,
            plan: {
                status: planResult.status ? "Complete" : "In Progress",
                result: planResult.result || "No results yet",
            },
            agents: this.skills.map((i) => ({
                name: i.name,
                description: i.description,
                tools: i.skills.map((i) => ({ name: i.name, description: i.description })),
            })),
        };
    }
    async getFullPlan(planResult, context) {
        return context.invoke(this.planner, this.getFullPlanInput(planResult));
    }
    async synthesizePlanResult(planResult, context) {
        return context.invoke(this.completer, {
            ...this.getFullPlanInput(planResult),
            message: orchestrator_prompts_js_1.SYNTHESIZE_PLAN_USER_PROMPT_TEMPLATE,
        });
    }
    async executeStep(planResult, step, context) {
        const concurrency = this.tasksConcurrency ?? DEFAULT_TASK_CONCURRENCY;
        const { model } = context;
        if (!model)
            throw new Error("model is required to run OrchestratorAgent");
        const queue = fastq_1.default.promise(async (task) => {
            const agent = this.skills.find((skill) => skill.name === task.agent);
            if (!agent)
                throw new Error(`Agent ${task.agent} not found`);
            const prompt = await core_1.PromptTemplate.from(orchestrator_prompts_js_1.TASK_PROMPT_TEMPLATE).format({
                objective: planResult.objective,
                step,
                task,
                steps: planResult.steps,
            });
            let result;
            if (agent.isInvokable) {
                result = getMessageOrJsonString(await context.invoke(agent, { message: prompt }));
            }
            else {
                const executor = core_1.AIAgent.from({
                    name: "llm_orchestration_task_executor",
                    instructions: prompt,
                    skills: agent.skills,
                });
                result = getMessageOrJsonString(await context.invoke(executor, {}));
            }
            return { task, result };
        }, concurrency);
        let results;
        try {
            results = await Promise.all(step.tasks.map((task) => queue.push(task)));
        }
        catch (error) {
            queue.kill();
            throw error;
        }
        const result = getMessageOrJsonString(await context.invoke(core_1.AIAgent.from({
            name: "llm_orchestration_step_synthesizer",
            instructions: orchestrator_prompts_js_1.SYNTHESIZE_STEP_PROMPT_TEMPLATE,
        }), { objective: planResult.objective, step, tasks: results }));
        if (!result)
            throw new Error("unexpected empty result from synthesize step's tasks results");
        return {
            step,
            tasks: results,
            result,
        };
    }
}
exports.OrchestratorAgent = OrchestratorAgent;
function getMessageOrJsonString(output) {
    const entries = Object.entries(output);
    const firstValue = entries[0]?.[1];
    if (entries.length === 1 && typeof firstValue === "string") {
        return firstValue;
    }
    return JSON.stringify(output);
}
const orchestratorAgentOptionsSchema = zod_1.z.object({
    maxIterations: zod_1.z.number().optional(),
    tasksConcurrency: zod_1.z.number().optional(),
});
