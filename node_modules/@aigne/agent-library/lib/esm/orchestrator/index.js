import { Agent, AIAgent, PromptTemplate, } from "@aigne/core";
import { checkArguments } from "@aigne/core/utils/type-utils.js";
import fastq from "fastq";
import { z } from "zod";
import { FULL_PLAN_PROMPT_TEMPLATE, getFullPlanSchema, SYNTHESIZE_PLAN_USER_PROMPT_TEMPLATE, SYNTHESIZE_STEP_PROMPT_TEMPLATE, TASK_PROMPT_TEMPLATE, } from "./orchestrator-prompts.js";
/**
 * Default maximum number of iterations to prevent infinite loops
 */
const DEFAULT_MAX_ITERATIONS = 30;
/**
 * Default number of concurrent tasks
 */
const DEFAULT_TASK_CONCURRENCY = 5;
/**
 * Re-export orchestrator prompt templates and related types
 */
export * from "./orchestrator-prompts.js";
/**
 * Orchestrator Agent Class
 *
 * This Agent is responsible for:
 * 1. Generating an execution plan based on the objective
 * 2. Breaking down the plan into steps and tasks
 * 3. Coordinating the execution of steps and tasks
 * 4. Synthesizing the final result
 *
 * Workflow:
 * - Receives input objective
 * - Uses planner to create execution plan
 * - Executes tasks and steps according to the plan
 * - Synthesizes final result through completer
 */
export class OrchestratorAgent extends Agent {
    tag = "OrchestratorAgent";
    /**
     * Factory method to create an OrchestratorAgent instance
     * @param options - Configuration options for the Orchestrator Agent
     * @returns A new OrchestratorAgent instance
     */
    static from(options) {
        return new OrchestratorAgent(options);
    }
    /**
     * Creates an OrchestratorAgent instance
     * @param options - Configuration options for the Orchestrator Agent
     */
    constructor(options) {
        checkArguments("OrchestratorAgent", orchestratorAgentOptionsSchema, options);
        super({ ...options });
        this.maxIterations = options.maxIterations;
        this.tasksConcurrency = options.tasksConcurrency;
        this.inputKey = options.inputKey;
        this.planner = new AIAgent({
            name: "llm_orchestration_planner",
            instructions: FULL_PLAN_PROMPT_TEMPLATE,
            outputSchema: () => getFullPlanSchema(this.skills),
        });
        this.completer = new AIAgent({
            name: "llm_orchestration_completer",
            instructions: FULL_PLAN_PROMPT_TEMPLATE,
            outputSchema: this.outputSchema,
        });
    }
    planner;
    completer;
    inputKey;
    /**
     * Maximum number of iterations
     * Prevents infinite execution loops
     */
    maxIterations;
    /**
     * Number of concurrent tasks
     * Controls how many tasks can be executed simultaneously
     */
    tasksConcurrency;
    /**
     * Process input and execute the orchestrator workflow
     *
     * Workflow:
     * 1. Extract the objective
     * 2. Loop until plan completion or maximum iterations:
     *    a. Generate/update execution plan
     *    b. If plan is complete, synthesize result
     *    c. Otherwise, execute steps in the plan
     *
     * @param input - Input message containing the objective
     * @param options - Agent invocation options
     * @returns Processing result
     */
    async process(input, options) {
        const { model } = options.context;
        if (!model)
            throw new Error("model is required to run OrchestratorAgent");
        const objective = input[this.inputKey];
        if (typeof objective !== "string")
            throw new Error("Objective is required to run OrchestratorAgent");
        const result = {
            objective,
            steps: [],
        };
        let iterations = 0;
        const maxIterations = this.maxIterations ?? DEFAULT_MAX_ITERATIONS;
        while (iterations++ < maxIterations) {
            const plan = await this.getFullPlan(result, options.context);
            result.plan = plan;
            if (plan.isComplete) {
                return this.synthesizePlanResult(result, options.context);
            }
            for (const step of plan.steps) {
                const stepResult = await this.executeStep(result, step, options.context);
                result.steps.push(stepResult);
            }
        }
        throw new Error(`Max iterations reached: ${maxIterations}`);
    }
    getFullPlanInput(planResult) {
        return {
            objective: planResult.objective,
            steps: planResult.steps,
            plan: {
                status: planResult.status ? "Complete" : "In Progress",
                result: planResult.result || "No results yet",
            },
            agents: this.skills.map((i) => ({
                name: i.name,
                description: i.description,
                tools: i.skills.map((i) => ({ name: i.name, description: i.description })),
            })),
        };
    }
    async getFullPlan(planResult, context) {
        return context.invoke(this.planner, this.getFullPlanInput(planResult));
    }
    async synthesizePlanResult(planResult, context) {
        return context.invoke(this.completer, {
            ...this.getFullPlanInput(planResult),
            message: SYNTHESIZE_PLAN_USER_PROMPT_TEMPLATE,
        });
    }
    async executeStep(planResult, step, context) {
        const concurrency = this.tasksConcurrency ?? DEFAULT_TASK_CONCURRENCY;
        const { model } = context;
        if (!model)
            throw new Error("model is required to run OrchestratorAgent");
        const queue = fastq.promise(async (task) => {
            const agent = this.skills.find((skill) => skill.name === task.agent);
            if (!agent)
                throw new Error(`Agent ${task.agent} not found`);
            const prompt = await PromptTemplate.from(TASK_PROMPT_TEMPLATE).format({
                objective: planResult.objective,
                step,
                task,
                steps: planResult.steps,
            });
            let result;
            if (agent.isInvokable) {
                result = getMessageOrJsonString(await context.invoke(agent, { message: prompt }));
            }
            else {
                const executor = AIAgent.from({
                    name: "llm_orchestration_task_executor",
                    instructions: prompt,
                    skills: agent.skills,
                });
                result = getMessageOrJsonString(await context.invoke(executor, {}));
            }
            return { task, result };
        }, concurrency);
        let results;
        try {
            results = await Promise.all(step.tasks.map((task) => queue.push(task)));
        }
        catch (error) {
            queue.kill();
            throw error;
        }
        const result = getMessageOrJsonString(await context.invoke(AIAgent.from({
            name: "llm_orchestration_step_synthesizer",
            instructions: SYNTHESIZE_STEP_PROMPT_TEMPLATE,
        }), { objective: planResult.objective, step, tasks: results }));
        if (!result)
            throw new Error("unexpected empty result from synthesize step's tasks results");
        return {
            step,
            tasks: results,
            result,
        };
    }
}
function getMessageOrJsonString(output) {
    const entries = Object.entries(output);
    const firstValue = entries[0]?.[1];
    if (entries.length === 1 && typeof firstValue === "string") {
        return firstValue;
    }
    return JSON.stringify(output);
}
const orchestratorAgentOptionsSchema = z.object({
    maxIterations: z.number().optional(),
    tasksConcurrency: z.number().optional(),
});
