"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenAIImageModel = void 0;
const core_1 = require("@aigne/core");
const camelize_js_1 = require("@aigne/core/utils/camelize.js");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const zod_1 = require("zod");
const openai_js_1 = require("./openai.js");
const DEFAULT_MODEL = "dall-e-2";
const openAIImageModelInputSchema = core_1.imageModelInputSchema.extend({});
const openAIImageModelOptionsSchema = zod_1.z.object({
    apiKey: zod_1.z.string().optional(),
    baseURL: zod_1.z.string().optional(),
    model: zod_1.z.string().optional(),
    modelOptions: zod_1.z.object({}).optional(),
    clientOptions: zod_1.z.object({}).optional(),
});
class OpenAIImageModel extends core_1.ImageModel {
    options;
    constructor(options) {
        super({
            ...options,
            inputSchema: openAIImageModelInputSchema,
            description: options?.description ?? "Draw or edit image by OpenAI image models",
        });
        this.options = options;
        if (options)
            (0, type_utils_js_1.checkArguments)(this.name, openAIImageModelOptionsSchema, options);
    }
    _client;
    apiKeyEnvName = "OPENAI_API_KEY";
    get client() {
        if (this._client)
            return this._client;
        const { apiKey, url } = this.credential;
        if (!apiKey)
            throw new Error(`${this.name} requires an API key. Please provide it via \`options.apiKey\`, or set the \`${this.apiKeyEnvName}\` environment variable`);
        this._client ??= new openai_js_1.CustomOpenAI({
            baseURL: url,
            apiKey,
            ...this.options?.clientOptions,
        });
        return this._client;
    }
    get credential() {
        return {
            url: this.options?.baseURL || process.env.OPENAI_BASE_URL,
            apiKey: this.options?.apiKey || process.env[this.apiKeyEnvName],
            model: this.options?.model || DEFAULT_MODEL,
        };
    }
    get modelOptions() {
        return this.options?.modelOptions;
    }
    /**
     * Process the input and generate a response
     * @param input The input to process
     * @returns The generated response
     */
    async process(input) {
        const model = input.model || this.credential.model;
        const map = {
            "dall-e-2": ["prompt", "size", "n"],
            "dall-e-3": ["prompt", "size", "n", "quality", "style", "user"],
            "gpt-image-1": [
                "prompt",
                "size",
                "background",
                "moderation",
                "outputCompression",
                "outputFormat",
                "quality",
                "user",
                "stream",
            ],
        };
        let responseFormat;
        if (model !== "gpt-image-1") {
            responseFormat = input.responseFormat === "base64" ? "b64_json" : "url";
        }
        const body = {
            ...(0, camelize_js_1.snakelize)((0, type_utils_js_1.pick)({ ...this.modelOptions, ...input }, map[model] || map["dall-e-2"])),
            response_format: responseFormat,
            model,
        };
        const response = await this.client.images.generate({ ...body });
        return {
            images: (response.data ?? []).map((image) => {
                if (image.url)
                    return { url: image.url };
                if (image.b64_json)
                    return { base64: image.b64_json };
                throw new Error("Image response does not contain a valid URL or base64 data");
            }),
            usage: {
                inputTokens: response.usage?.input_tokens || 0,
                outputTokens: response.usage?.output_tokens || 0,
            },
            model,
        };
    }
}
exports.OpenAIImageModel = OpenAIImageModel;
