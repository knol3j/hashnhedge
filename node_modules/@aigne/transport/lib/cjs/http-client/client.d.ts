import { type Agent, type AgentResponse, type AgentResponseStream, type Context, type ContextEmitEventMap, type ContextEventMap, type ContextUsage, type InvokeOptions, type Message, type MessagePayload, type MessageQueueListener, type Unsubscribe, type UserAgent, type UserContext } from "@aigne/core";
import type { Args, Listener } from "@aigne/core/utils/typed-event-emitter.js";
import { BaseClient, type BaseClientInvokeOptions, type BaseClientOptions } from "./base-client.js";
import { ClientAgent, type ClientAgentOptions } from "./client-agent.js";
import { ClientChatModel } from "./client-chat-model.js";
/**
 * Configuration options for the AIGNEHTTPClient.
 */
export interface AIGNEHTTPClientOptions extends BaseClientOptions {
}
/**
 * Options for invoking an agent through the AIGNEHTTPClient.
 * Extends the standard AgentInvokeOptions with client-specific options.
 */
export interface AIGNEHTTPClientInvokeOptions extends BaseClientInvokeOptions {
}
/**
 * Http client for interacting with a remote AIGNE server.
 * AIGNEHTTPClient provides a client-side interface that matches the AIGNE API,
 * allowing applications to invoke agents and receive responses from a remote AIGNE instance.
 *
 * @example
 * Here's a simple example of how to use AIGNEClient:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-simple}
 *
 * @example
 * Here's an example of how to use AIGNEClient with streaming response:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-streaming}
 */
export declare class AIGNEHTTPClient<U extends UserContext = UserContext> extends BaseClient implements Context<U> {
    options: AIGNEHTTPClientOptions;
    /**
     * Creates a new AIGNEClient instance.
     *
     * @param options - Configuration options for connecting to the AIGNE server
     */
    constructor(options: AIGNEHTTPClientOptions);
    id: string;
    rootId: string;
    usage: ContextUsage;
    userContext: U;
    memories: Context["memories"];
    model: ClientChatModel;
    agents: never[];
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string): UserAgent<I, O>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message: I, options: AIGNEHTTPClientInvokeOptions & {
        returnActiveAgent: true;
        streaming?: false;
    }): Promise<[O, Agent]>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message: I, options: AIGNEHTTPClientInvokeOptions & {
        returnActiveAgent: true;
        streaming: true;
    }): Promise<[AgentResponseStream<O>, Promise<Agent>]>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message: I, options?: AIGNEHTTPClientInvokeOptions & {
        returnActiveAgent?: false;
        streaming?: false;
    }): Promise<O>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message: I, options: AIGNEHTTPClientInvokeOptions & {
        returnActiveAgent?: false;
        streaming: true;
    }): Promise<AgentResponseStream<O>>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message: I, options: AIGNEHTTPClientInvokeOptions & {
        returnActiveAgent?: false;
    }): Promise<O | AgentResponseStream<O>>;
    invoke<I extends Message, O extends Message>(agent: Agent<I, O> | string, message?: I, options?: AIGNEHTTPClientInvokeOptions): UserAgent<I, O> | Promise<AgentResponse<O> | [AgentResponse<O>, Agent]>;
    publish(_topic: string | string[], _payload: Omit<MessagePayload, "context"> | Message | string, _options?: InvokeOptions): void;
    subscribe(topic: string | string[], listener?: undefined): Promise<MessagePayload>;
    subscribe(topic: string | string[], listener: MessageQueueListener): Unsubscribe;
    subscribe(topic: string | string[], listener?: MessageQueueListener): Unsubscribe | Promise<MessagePayload>;
    subscribe(topic: string | string[], listener?: MessageQueueListener): Unsubscribe | Promise<MessagePayload>;
    unsubscribe(_topic: string | string[], _listener: MessageQueueListener): void;
    newContext(_options?: {
        reset?: boolean;
    }): Context;
    emit<K extends keyof ContextEventMap>(_eventName: K, ..._args: Args<K, ContextEmitEventMap>): boolean;
    on<K extends keyof ContextEventMap>(_eventName: K, _listener: Listener<K, ContextEventMap>): this;
    once<K extends keyof ContextEventMap>(_eventName: K, _listener: Listener<K, ContextEventMap>): this;
    off<K extends keyof ContextEventMap>(_eventName: K, _listener: Listener<K, ContextEventMap>): this;
    /**
     * Invokes an agent in non-streaming mode and returns the complete response.
     *
     * @param agent - Name of the agent to invoke
     * @param input - Input message for the agent
     * @param options - Options with streaming mode explicitly set to false or omitted
     * @returns The complete agent response
     *
     * @example
     * Here's a simple example of how to use AIGNEClient:
     * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-simple}
     */
    _invoke<I extends Message, O extends Message>(agent: string, input: string | I, options?: AIGNEHTTPClientInvokeOptions & {
        streaming?: false;
    }): Promise<O>;
    /**
     * Invokes an agent with streaming mode enabled and returns a stream of response chunks.
     *
     * @param agent - Name of the agent to invoke
     * @param input - Input message for the agent
     * @param options - Options with streaming mode explicitly set to true
     * @returns A stream of agent response chunks
     *
     * @example
     * Here's an example of how to use AIGNEClient with streaming response:
     * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-streaming}
     */
    _invoke<I extends Message, O extends Message>(agent: string, input: string | I, options: AIGNEHTTPClientInvokeOptions & {
        streaming: true;
    }): Promise<AgentResponseStream<O>>;
    /**
     * Invokes an agent with the given input and options.
     *
     * @param agent - Name of the agent to invoke
     * @param input - Input message for the agent
     * @param options - Options for the invocation
     * @returns Either a complete response or a response stream depending on the streaming option
     */
    _invoke<I extends Message, O extends Message>(agent: string, input: string | I, options?: AIGNEHTTPClientInvokeOptions): Promise<AgentResponse<O>>;
    getAgent<I extends Message = Message, O extends Message = Message>(options: ClientAgentOptions<I, O>): Promise<ClientAgent<I, O>>;
}
