"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIGNEHTTPClient = void 0;
const core_1 = require("@aigne/core");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const uuid_1 = require("uuid");
const base_client_js_1 = require("./base-client.js");
const client_agent_js_1 = require("./client-agent.js");
const client_chat_model_js_1 = require("./client-chat-model.js");
/**
 * Http client for interacting with a remote AIGNE server.
 * AIGNEHTTPClient provides a client-side interface that matches the AIGNE API,
 * allowing applications to invoke agents and receive responses from a remote AIGNE instance.
 *
 * @example
 * Here's a simple example of how to use AIGNEClient:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-simple}
 *
 * @example
 * Here's an example of how to use AIGNEClient with streaming response:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-streaming}
 */
class AIGNEHTTPClient extends base_client_js_1.BaseClient {
    options;
    /**
     * Creates a new AIGNEClient instance.
     *
     * @param options - Configuration options for connecting to the AIGNE server
     */
    constructor(options) {
        super(options);
        this.options = options;
    }
    id = (0, uuid_1.v7)();
    rootId = this.id;
    usage = (0, core_1.newEmptyContextUsage)();
    userContext = {};
    memories = [];
    model = new client_chat_model_js_1.ClientChatModel(this);
    agents = [];
    invoke(agent, message, options) {
        if (options?.returnActiveAgent)
            throw new Error("Method not implemented.");
        if (!message)
            throw new Error("Message is required for invoking an agent");
        if (options?.userContext) {
            Object.assign(this.userContext, options.userContext);
            options.userContext = undefined;
        }
        if (options?.memories?.length) {
            this.memories.push(...options.memories);
            options.memories = undefined;
        }
        const a = typeof agent === "string" ? this.getAgent({ name: agent }) : Promise.resolve(agent);
        return a.then((agent) => agent.invoke(message, { ...options, context: this }));
    }
    publish(_topic, _payload, _options) {
        console.error("Method not implemented.");
    }
    subscribe(_topic, _listener) {
        console.error("Method not implemented.");
        return () => { };
    }
    unsubscribe(_topic, _listener) {
        console.error("Method not implemented.");
    }
    newContext(_options) {
        throw new Error("Method not implemented.");
    }
    emit(_eventName, ..._args) {
        console.error("Method not implemented.");
        return false;
    }
    on(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    once(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    off(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    async _invoke(agent, input, options = {}) {
        return this.__invoke(agent, input, {
            ...(0, type_utils_js_1.omit)(options, "context"),
            userContext: { ...this.userContext, ...options.userContext },
            memories: [...this.memories, ...(options.memories ?? [])],
        });
    }
    async getAgent(options) {
        return new client_agent_js_1.ClientAgent(this, options);
    }
}
exports.AIGNEHTTPClient = AIGNEHTTPClient;
