"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AIGNEHTTPServer = exports.invokePayloadSchema = void 0;
const node_http_1 = require("node:http");
const event_stream_js_1 = require("@aigne/core/utils/event-stream.js");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const content_type_1 = __importDefault(require("content-type"));
const raw_body_1 = __importDefault(require("raw-body"));
const zod_1 = require("zod");
const constants_js_1 = require("../constants.js");
const error_js_1 = require("./error.js");
/**
 * Default maximum allowed size for request bodies when parsing raw HTTP requests.
 * This limits the amount of data that can be uploaded to protect against denial of service attacks.
 * Can be overridden via AIGNEServerOptions.
 * @internal
 */
const DEFAULT_MAXIMUM_BODY_SIZE = "4mb";
/**
 * Schema for validating agent invocation payloads.
 * Defines the expected structure for requests to invoke an agent.
 *
 * @hidden
 */
exports.invokePayloadSchema = zod_1.z.object({
    agent: zod_1.z.string(),
    input: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
    options: zod_1.z
        .object({
        streaming: zod_1.z
            .boolean()
            .nullish()
            .transform((v) => v ?? undefined),
        returnProgressChunks: zod_1.z
            .boolean()
            .nullish()
            .transform((v) => v ?? undefined),
        userContext: zod_1.z
            .record(zod_1.z.string(), zod_1.z.unknown())
            .nullish()
            .transform((v) => v ?? undefined),
        memories: zod_1.z
            .array(zod_1.z.object({ content: zod_1.z.custom() }))
            .nullish()
            .transform((v) => v ?? undefined),
    })
        .nullish()
        .transform((v) => v ?? undefined),
});
/**
 * AIGNEHTTPServer provides HTTP API access to AIGNE capabilities.
 * It handles requests to invoke agents, manages response streaming,
 * and supports multiple HTTP server frameworks including Node.js http,
 * Express, and Fetch API compatible environments.
 *
 * @example
 * Here's a simple example of how to use AIGNEServer with express:
 * {@includeCode ../../test/http-server/http-server.test.ts#example-aigne-server-express}
 *
 * @example
 * Here's an example of how to use AIGNEServer with Hono:
 * {@includeCode ../../test/http-server/http-server.test.ts#example-aigne-server-hono}
 */
class AIGNEHTTPServer {
    aigne;
    options;
    /**
     * Creates a new AIGNEServer instance.
     *
     * @param aigne - The AIGNE instance that will process agent invocations
     * @param options - Configuration options for the server
     */
    constructor(aigne, options) {
        this.aigne = aigne;
        this.options = options;
    }
    async invoke(request, response, options) {
        const opts = !(response instanceof node_http_1.ServerResponse) ? options || response : options;
        const result = await this._invoke(request, {
            userContext: opts?.userContext,
            memories: opts?.memories,
            hooks: opts?.hooks,
        });
        if (response instanceof node_http_1.ServerResponse) {
            await this._writeResponse(result, response);
            return;
        }
        return result;
    }
    /**
     * Internal method that handles the core logic of processing an agent invocation request.
     * Validates the request payload, finds the requested agent, and processes the invocation
     * with either streaming or non-streaming response handling.
     *
     * @param request - The parsed or raw request to process
     * @param options - Additional options for the invocation, such as user context and memories
     * @returns A standard Response object with the invocation result
     * @private
     */
    async _invoke(request, options = {}) {
        const { aigne } = this;
        try {
            const payload = await this._prepareInput(request);
            const { agent: agentName, input, options: { streaming, ...opts } = {}, } = (0, type_utils_js_1.tryOrThrow)(() => (0, type_utils_js_1.checkArguments)(`Invoke agent ${payload.agent}`, exports.invokePayloadSchema, payload), (error) => new error_js_1.ServerError(400, error.message));
            const agent = agentName === constants_js_1.ChatModelName ? aigne.model : aigne.agents[agentName];
            if (!agent)
                throw new error_js_1.ServerError(404, `Agent ${agentName} not found`);
            const mergedOptions = {
                returnProgressChunks: opts.returnProgressChunks,
                userContext: { ...opts.userContext, ...options.userContext },
                memories: [...(opts.memories ?? []), ...(options.memories ?? [])],
                hooks: options.hooks,
            };
            if (!streaming) {
                const result = await aigne.invoke(agent, input, mergedOptions);
                return new Response(JSON.stringify(result), {
                    headers: { "Content-Type": "application/json" },
                });
            }
            const stream = await aigne.invoke(agent, input, {
                ...mergedOptions,
                returnActiveAgent: false,
                streaming: true,
            });
            return new Response(new event_stream_js_1.AgentResponseStreamSSE(stream), {
                headers: {
                    "Content-Type": "text/event-stream",
                    "Cache-Control": "no-cache",
                    "X-Accel-Buffering": "no",
                },
            });
        }
        catch (error) {
            return new Response(JSON.stringify({ error: { message: error.message } }), {
                status: error instanceof error_js_1.ServerError ? error.status : 500,
                headers: { "Content-Type": "application/json" },
            });
        }
    }
    /**
     * Prepares and normalizes the input from various request types.
     * Handles different request formats (Node.js IncomingMessage, Fetch API Request,
     * or already parsed object) and extracts the JSON payload.
     *
     * @param request - The request object in any supported format
     * @returns The normalized payload as a JavaScript object
     * @private
     */
    async _prepareInput(request) {
        const contentTypeError = new error_js_1.ServerError(415, "Unsupported Media Type: Content-Type must be application/json");
        if (request instanceof node_http_1.IncomingMessage) {
            // Support for express with json() middleware
            if ("body" in request && typeof request.body === "object") {
                if (!(0, type_utils_js_1.isRecord)(request.body))
                    throw contentTypeError;
                return request.body;
            }
            // Support vanilla nodejs http server
            const maximumBodySize = this.options?.maximumBodySize || DEFAULT_MAXIMUM_BODY_SIZE;
            const ct = request.headers["content-type"];
            if (!ct || !ct.includes("application/json"))
                throw contentTypeError;
            const parsedCt = content_type_1.default.parse(ct);
            const raw = await (0, raw_body_1.default)(request, {
                limit: maximumBodySize,
                encoding: parsedCt.parameters.charset ?? "utf-8",
            });
            return (0, type_utils_js_1.tryOrThrow)(() => JSON.parse(raw.toString()), (error) => new error_js_1.ServerError(400, `Parse request body to json error: ${error.message}`));
        }
        if (request instanceof Request) {
            if (!request.headers.get("content-type")?.includes("application/json")) {
                throw contentTypeError;
            }
            return await request.json();
        }
        if (!(0, type_utils_js_1.isRecord)(request))
            throw contentTypeError;
        return request;
    }
    /**
     * Writes a web standard Response object to a Node.js ServerResponse.
     * Handles streaming responses and error conditions appropriately.
     *
     * @param response - The web standard Response object to write
     * @param res - The Node.js ServerResponse to write to
     * @private
     */
    async _writeResponse(response, res) {
        try {
            res.writeHead(response.status, Object.fromEntries(response.headers.entries()));
            res.flushHeaders();
            if (!response.body)
                throw new Error("Response body is empty");
            for await (const chunk of response.body) {
                res.write(chunk);
                // Support for express with compression middleware
                if ("flush" in res && typeof res.flush === "function") {
                    res.flush();
                }
            }
        }
        catch (error) {
            if (!res.headersSent) {
                res.writeHead(error instanceof error_js_1.ServerError ? error.status : 500, {
                    "Content-Type": "application/json",
                });
            }
            if (res.writable) {
                res.write(JSON.stringify({ error: { message: error.message } }));
            }
        }
        finally {
            res.end();
        }
    }
}
exports.AIGNEHTTPServer = AIGNEHTTPServer;
