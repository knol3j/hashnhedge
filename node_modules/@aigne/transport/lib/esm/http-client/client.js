import { newEmptyContextUsage, } from "@aigne/core";
import { omit } from "@aigne/core/utils/type-utils.js";
import { v7 } from "uuid";
import { BaseClient } from "./base-client.js";
import { ClientAgent } from "./client-agent.js";
import { ClientChatModel } from "./client-chat-model.js";
/**
 * Http client for interacting with a remote AIGNE server.
 * AIGNEHTTPClient provides a client-side interface that matches the AIGNE API,
 * allowing applications to invoke agents and receive responses from a remote AIGNE instance.
 *
 * @example
 * Here's a simple example of how to use AIGNEClient:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-simple}
 *
 * @example
 * Here's an example of how to use AIGNEClient with streaming response:
 * {@includeCode ../../test/http-client/http-client.test.ts#example-aigne-client-streaming}
 */
export class AIGNEHTTPClient extends BaseClient {
    options;
    /**
     * Creates a new AIGNEClient instance.
     *
     * @param options - Configuration options for connecting to the AIGNE server
     */
    constructor(options) {
        super(options);
        this.options = options;
    }
    id = v7();
    rootId = this.id;
    usage = newEmptyContextUsage();
    userContext = {};
    memories = [];
    model = new ClientChatModel(this);
    agents = [];
    invoke(agent, message, options) {
        if (options?.returnActiveAgent)
            throw new Error("Method not implemented.");
        if (!message)
            throw new Error("Message is required for invoking an agent");
        if (options?.userContext) {
            Object.assign(this.userContext, options.userContext);
            options.userContext = undefined;
        }
        if (options?.memories?.length) {
            this.memories.push(...options.memories);
            options.memories = undefined;
        }
        const a = typeof agent === "string" ? this.getAgent({ name: agent }) : Promise.resolve(agent);
        return a.then((agent) => agent.invoke(message, { ...options, context: this }));
    }
    publish(_topic, _payload, _options) {
        console.error("Method not implemented.");
    }
    subscribe(_topic, _listener) {
        console.error("Method not implemented.");
        return () => { };
    }
    unsubscribe(_topic, _listener) {
        console.error("Method not implemented.");
    }
    newContext(_options) {
        throw new Error("Method not implemented.");
    }
    emit(_eventName, ..._args) {
        console.error("Method not implemented.");
        return false;
    }
    on(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    once(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    off(_eventName, _listener) {
        console.error("Method not implemented.");
        return this;
    }
    async _invoke(agent, input, options = {}) {
        return this.__invoke(agent, input, {
            ...omit(options, "context"),
            userContext: { ...this.userContext, ...options.userContext },
            memories: [...this.memories, ...(options.memories ?? [])],
        });
    }
    async getAgent(options) {
        return new ClientAgent(this, options);
    }
}
