"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMemoryRecorder = exports.DefaultMemoryRetriever = exports.DefaultMemory = void 0;
const core_1 = require("@aigne/core");
const type_utils_js_1 = require("@aigne/core/utils/type-utils.js");
const index_js_1 = require("./default-memory-storage/index.js");
const storage_js_1 = require("./storage.js");
const DEFAULT_RETRIEVE_MEMORY_COUNT = 10;
class DefaultMemory extends core_1.MemoryAgent {
    constructor(options = {}) {
        const storage = options.storage instanceof storage_js_1.MemoryStorage
            ? options.storage
            : new index_js_1.DefaultMemoryStorage(options.storage);
        super({
            ...options,
            recorder: options.recorder ?? new DefaultMemoryRecorder({ ...options, storage }),
            retriever: options.retriever ??
                new DefaultMemoryRetriever({
                    ...options,
                    retrieveRecentMemoryCount: options.retrieveRecentMemoryCount ??
                        Math.ceil(options.retrieveMemoryCount ?? DEFAULT_RETRIEVE_MEMORY_COUNT) / 2,
                    storage,
                }),
            autoUpdate: options.autoUpdate ?? true,
        });
        this.storage = storage;
    }
    storage;
}
exports.DefaultMemory = DefaultMemory;
class DefaultMemoryRetriever extends core_1.MemoryRetriever {
    constructor(options) {
        super(options);
        this.storage = options.storage;
        this.retrieveMemoryCount = options.retrieveMemoryCount;
        this.retrieveRecentMemoryCount = options.retrieveRecentMemoryCount;
        this.inputKey = (0, type_utils_js_1.flat)(options.inputKey);
        this.outputKey = (0, type_utils_js_1.flat)(options.outputKey);
        if (options.getSearchPattern)
            this.getSearchPattern = options.getSearchPattern;
        if (options.formatMessage)
            this.formatMessage = options.formatMessage;
        if (options.formatMemory)
            this.formatMemory = options.formatMemory;
    }
    storage;
    retrieveMemoryCount;
    retrieveRecentMemoryCount;
    inputKey;
    outputKey;
    getSearchPattern = (search) => {
        if (!search || typeof search === "string")
            return search;
        const obj = search && this.inputKey ? (0, type_utils_js_1.pick)(search, this.inputKey) : search;
        return Object.values(obj)
            .map((v) => (typeof v === "string" ? v : undefined))
            .join("\n");
    };
    formatMessage = (content, key) => {
        if (!(0, type_utils_js_1.isRecord)(content))
            return content;
        const obj = !key?.length ? content : (0, type_utils_js_1.pick)(content, key);
        return Object.values(obj)
            .map((v) => (typeof v === "string" ? v : undefined))
            .join("\n");
    };
    formatMemory = (content) => {
        if ((0, type_utils_js_1.isRecord)(content) && "input" in content && "output" in content) {
            return {
                input: this.formatMessage(content.input, this.inputKey),
                output: this.formatMessage(content.output, this.outputKey),
                source: content.source,
            };
        }
        return content;
    };
    async process(input, options) {
        const limit = input.limit ?? this.retrieveMemoryCount ?? DEFAULT_RETRIEVE_MEMORY_COUNT;
        const search = this.getSearchPattern(input.search);
        const recentLimit = this.retrieveRecentMemoryCount;
        const [recent, related] = await Promise.all([
            // Query latest messages
            !recentLimit
                ? []
                : this.storage
                    .search({ limit: recentLimit, orderBy: ["createdAt", "desc"] }, options)
                    .then(({ result }) => result.reverse()),
            // Query related messages
            !input.search
                ? []
                : this.storage.search({ ...input, search, limit }, options).then(({ result }) => result),
        ]);
        const recentSet = new Set(recent.map((i) => i.id));
        const memories = related
            // Filter out recent memories from related results
            .filter((i) => !recentSet.has(i.id))
            .concat(recent)
            .slice(-limit);
        return {
            memories: memories.map((i) => ({
                ...i,
                content: this.formatMemory(i.content),
            })),
        };
    }
}
exports.DefaultMemoryRetriever = DefaultMemoryRetriever;
class DefaultMemoryRecorder extends core_1.MemoryRecorder {
    constructor(options) {
        super(options);
        this.storage = options.storage;
        this.inputKey = (0, type_utils_js_1.flat)(options.inputKey);
        this.outputKey = (0, type_utils_js_1.flat)(options.outputKey);
    }
    storage;
    inputKey;
    outputKey;
    async process(input, options) {
        const newMemories = [];
        for (const item of input.content) {
            const { result } = await this.storage.create({
                content: {
                    input: item.input && this.inputKey?.length ? (0, type_utils_js_1.pick)(item.input, this.inputKey) : item.input,
                    output: item.output && this.outputKey?.length
                        ? (0, type_utils_js_1.pick)(item.output, this.outputKey)
                        : item.output,
                    source: item.source,
                },
            }, options);
            newMemories.push(result);
        }
        return {
            memories: newMemories,
        };
    }
}
exports.DefaultMemoryRecorder = DefaultMemoryRecorder;
