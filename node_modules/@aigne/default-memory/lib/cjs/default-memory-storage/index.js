"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMemoryStorage = void 0;
const sqlite_1 = require("@aigne/sqlite");
const drizzle_orm_1 = require("drizzle-orm");
const uuid_1 = require("uuid");
const yaml_1 = require("yaml");
const storage_js_1 = require("../storage.js");
const migrate_js_1 = require("./migrate.js");
const memory_js_1 = require("./models/memory.js");
const DEFAULT_MAX_MEMORY_COUNT = 10;
class DefaultMemoryStorage extends storage_js_1.MemoryStorage {
    options;
    constructor(options) {
        super();
        this.options = options;
    }
    _db;
    async initSqlite() {
        const db = (await (0, sqlite_1.initDatabase)({ url: this.options?.url }));
        await (0, migrate_js_1.migrate)(db);
        return db;
    }
    get db() {
        this._db ??= this.initSqlite();
        return this._db;
    }
    convertMemory(m) {
        return {
            id: m.id,
            sessionId: m.sessionId,
            content: m.content,
            createdAt: m.createdAt.toISOString(),
        };
    }
    async search(query, { context }) {
        const { limit = DEFAULT_MAX_MEMORY_COUNT } = query;
        const sessionId = (await this.options?.getSessionId?.(context)) ?? null;
        const db = await this.db;
        const match = this.options?.enableFTS && query.search ? this.segment(query.search).join(" OR ") : undefined;
        const memories = match
            ? await db
                .select()
                .from(memory_js_1.Memories)
                .innerJoin((0, drizzle_orm_1.sql) `Memories_fts`, (0, drizzle_orm_1.sql) `Memories_fts.id = ${memory_js_1.Memories.id}`)
                .where((0, drizzle_orm_1.sql) `Memories_fts MATCH ${drizzle_orm_1.sql.param(match)}`)
                .orderBy((0, drizzle_orm_1.sql) `bm25(Memories_fts)`)
                .limit(limit)
                .execute()
                .then((rows) => rows.map((row) => row.Memories))
            : await db
                .select()
                .from(memory_js_1.Memories)
                .where(sessionId ? (0, drizzle_orm_1.eq)(memory_js_1.Memories.sessionId, sessionId) : (0, drizzle_orm_1.isNull)(memory_js_1.Memories.sessionId))
                .orderBy(query.orderBy
                ? (query.orderBy[1] === "asc" ? drizzle_orm_1.asc : drizzle_orm_1.desc)(drizzle_orm_1.sql.identifier(query.orderBy[0]))
                : (0, drizzle_orm_1.desc)(memory_js_1.Memories.id))
                .limit(limit)
                .execute();
        return {
            result: memories.map(this.convertMemory),
        };
    }
    async create(memory, { context }) {
        const sessionId = (await this.options?.getSessionId?.(context)) ?? null;
        const db = await this.db;
        const id = (0, uuid_1.v7)();
        const [[result]] = await Promise.all([
            db
                .insert(memory_js_1.Memories)
                .values({
                ...memory,
                id,
                content: memory.content,
                sessionId,
            })
                .returning()
                .execute(),
            this.options?.enableFTS &&
                db.run((0, drizzle_orm_1.sql) `\
          insert into Memories_fts (id, content)
          values (${drizzle_orm_1.sql.param(id)}, ${drizzle_orm_1.sql.param(this.segment((0, yaml_1.stringify)(memory.content)).join(" "))})`),
        ]);
        if (!result)
            throw new Error("Failed to create memory");
        return { result: this.convertMemory(result) };
    }
    segment(str) {
        return (Array.from(new Intl.Segmenter(undefined, { granularity: "word" }).segment(str))
            .map((i) => i.segment)
            // Remove non-alphanumeric characters and trim whitespace
            .map((i) => i.replace(/[^\p{L}\p{N}\s]/gu, "").trim())
            .filter(Boolean));
    }
}
exports.DefaultMemoryStorage = DefaultMemoryStorage;
