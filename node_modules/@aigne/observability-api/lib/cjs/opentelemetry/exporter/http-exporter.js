"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sqlite_1 = require("@aigne/sqlite");
const core_1 = require("@opentelemetry/core");
const drizzle_orm_1 = require("drizzle-orm");
const util_js_1 = require("../../core/util.js");
const migrate_js_1 = require("../../server/migrate.js");
const util_js_2 = require("./util.js");
class HttpExporter {
    dbPath;
    _db;
    upsert;
    async getDb() {
        if (util_js_1.isBlocklet)
            return;
        const db = await (0, sqlite_1.initDatabase)({ url: this.dbPath, wal: true });
        await (0, migrate_js_1.migrate)(db);
        return db;
    }
    constructor({ dbPath, exportFn, }) {
        this.dbPath = dbPath;
        this._db ??= this.getDb();
        this.upsert =
            exportFn ??
                (util_js_1.isBlocklet
                    ? async () => {
                        console.warn("Please setup AIGNEObserver.setExportFn to collect tracing data from agents.");
                    }
                    : this._upsertWithSQLite);
    }
    async _upsertWithSQLite(validatedData) {
        const db = await this._db;
        if (!db)
            throw new Error("Database not initialized");
        for (const trace of validatedData) {
            const insertSql = (0, drizzle_orm_1.sql) `
        INSERT INTO Trace (
          id,
          rootId,
          parentId,
          name,
          startTime,
          endTime,
          attributes,
          status,
          userId,
          sessionId,
          componentId,
          action
        ) VALUES (
          ${trace.id},
          ${trace.rootId},
          ${trace.parentId || null},
          ${trace.name},
          ${trace.startTime},
          ${trace.endTime},
          ${JSON.stringify(trace.attributes)},
          ${JSON.stringify(trace.status)},
          ${trace.userId || null},
          ${trace.sessionId || null},
          ${trace.componentId || null},
          ${trace.action || null}
        )
        ON CONFLICT(id)
        DO UPDATE SET
          name = excluded.name,
          startTime = excluded.startTime,
          endTime = excluded.endTime,
          attributes = excluded.attributes,
          status = excluded.status,
          userId = excluded.userId,
          sessionId = excluded.sessionId,
          componentId = excluded.componentId,
          action = excluded.action;
      `;
            await db?.run?.(insertSql);
        }
    }
    async export(spans, resultCallback) {
        try {
            await this.upsert((0, util_js_2.validateTraceSpans)(spans));
            resultCallback({ code: core_1.ExportResultCode.SUCCESS });
        }
        catch (error) {
            console.error("Failed to export spans:", error);
            resultCallback({ code: core_1.ExportResultCode.FAILED });
        }
    }
    shutdown() {
        return Promise.resolve();
    }
}
exports.default = HttpExporter;
