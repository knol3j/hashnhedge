"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Direction = void 0;
exports.calcConstantPrice = calcConstantPrice;
exports.calcConstantCost = calcConstantCost;
exports.calcLinearPrice = calcLinearPrice;
exports.calcLinearCost = calcLinearCost;
exports.calcQuadraticPrice = calcQuadraticPrice;
exports.calcQuadraticCost = calcQuadraticCost;
exports.calcFee = calcFee;
exports.calcPrice = calcPrice;
exports.calcCost = calcCost;
const index_1 = require("./index");
const ZERO = new index_1.BN(0);
const TWO = new index_1.BN(2);
const THREE = new index_1.BN(3);
const TEN = new index_1.BN(10);
var Direction;
(function (Direction) {
    Direction["Mint"] = "mint";
    Direction["Burn"] = "burn";
})(Direction || (exports.Direction = Direction = {}));
/**
 * Constant Curve
 * Price = fixedPrice
 */
function calcConstantPrice({ fixedPrice }) {
    return new index_1.BN(fixedPrice);
}
/**
 * Constant Curve
 * Cost = amount * fixedPrice
 */
function calcConstantCost({ amount, fixedPrice, decimal, }) {
    const decimalFactor = TEN.pow(new index_1.BN(decimal));
    return new index_1.BN(amount).mul(new index_1.BN(fixedPrice)).div(decimalFactor);
}
/**
 * linear Curve
 * Price = basePrice + slope * currentSupply
 */
function calcLinearPrice({ basePrice, slope, currentSupply, decimal, }) {
    const decimalFactor = TEN.pow(new index_1.BN(decimal));
    return new index_1.BN(basePrice).add(new index_1.BN(slope).mul(new index_1.BN(currentSupply)).div(decimalFactor));
}
/**
 * Linear Curve
 * mint Cost = (slope / 2) * ( (currentSupply + amount) ** 2 - currentSupply ** 2 ) + basePrice * amount;
 * burn Cost = (slope / 2) * ( currentSupply ** 2 - (currentSupply - amount) ** 2 ) + basePrice * amount;
 */
function calcLinearCost(params) {
    const amount = new index_1.BN(params.amount);
    const currentSupply = new index_1.BN(params.currentSupply);
    const basePrice = new index_1.BN(params.basePrice);
    const slope = new index_1.BN(params.slope);
    const decimalFactor = TEN.pow(new index_1.BN(params.decimal));
    if (slope.lte(ZERO))
        throw new Error('INVALID_SLOPE');
    if (amount.lt(ZERO))
        throw new Error('INVALID_AMOUNT');
    if (currentSupply.lt(ZERO))
        throw new Error('INVALID_CURRENT_SUPPLY');
    if (basePrice.lt(ZERO))
        throw new Error('INVALID_BASE_PRICE');
    if (decimalFactor.lte(ZERO))
        throw new Error('INVALID_DECIMAL_FACTOR');
    if (params.direction === Direction.Burn && amount.gt(currentSupply)) {
        throw new Error('SUPPLY_INSUFFICIENT');
    }
    const integralDelta = params.direction === Direction.Mint
        ? amount.mul(currentSupply.mul(TWO).add(amount)) // (currentSupply + amount) ** 2 - currentSupply ** 2 = amount * (2 * currentSupply + amount)
        : amount.mul(currentSupply.mul(TWO).sub(amount)); // currentSupply ** 2 - (currentSupply - amount) ** 2 = amount * (2 * currentSupply - amount)
    const linearTerm = basePrice.mul(amount).div(decimalFactor);
    const integralTerm = slope.mul(integralDelta).div(TWO.mul(decimalFactor.sqr()));
    return linearTerm.add(integralTerm);
}
/**
 * Quadratic Curve
 * Price = basePrice + currentSupply ** 2 / constant
 */
function calcQuadraticPrice(params) {
    const basePrice = new index_1.BN(params.basePrice);
    const currentSupply = new index_1.BN(params.currentSupply);
    const constant = new index_1.BN(params.constant);
    const decimalFactor = TEN.pow(new index_1.BN(params.decimal)); // 10^decimal
    if (constant.lte(ZERO))
        throw new Error('INVALID_CONSTANT');
    if (currentSupply.lt(ZERO))
        throw new Error('INVALID_CURRENT_SUPPLY');
    if (basePrice.lt(ZERO))
        throw new Error('INVALID_BASE_PRICE');
    if (decimalFactor.lte(ZERO))
        throw new Error('INVALID_DECIMAL_FACTOR');
    // Single division to reduce double-flooring error
    const denom = constant.mul(decimalFactor);
    const a = currentSupply.sqr().div(denom);
    return basePrice.add(a);
}
/**
 * Quadratic Curve
 * Price = basePrice + currentSupply ** 2 / constant
 * mint Cost = ( (currentSupply + amount)^3 / 3 - currentSupply^3 / 3 ) / constant + basePrice * amount;
 * burn Cost = ( currentSupply^3 / 3 - (currentSupply - amount)^3 / 3 ) / constant + basePrice * amount;
 */
function calcQuadraticCost(params) {
    const amount = new index_1.BN(params.amount);
    const currentSupply = new index_1.BN(params.currentSupply);
    const basePrice = new index_1.BN(params.basePrice);
    const constant = new index_1.BN(params.constant);
    const decimalFactor = TEN.pow(new index_1.BN(params.decimal)); // M = 10^decimal
    // Basic validations
    if (constant.lte(ZERO))
        throw new Error('INVALID_CONSTANT');
    if (amount.lt(ZERO))
        throw new Error('INVALID_AMOUNT');
    if (amount.isZero())
        return ZERO;
    // Compute new supply with direction guard
    const newSupply = params.direction === Direction.Mint ? currentSupply.add(amount) : currentSupply.sub(amount);
    if (params.direction === Direction.Burn && newSupply.lt(ZERO)) {
        throw new Error('SUPPLY_INSUFFICIENT');
    }
    // cubicDelta = |S1^3 - S0^3| = (S1 - S0) * (S1^2 + S1 * S0 + S0^2)
    const diff = params.direction === Direction.Mint ? newSupply.sub(currentSupply) : currentSupply.sub(newSupply);
    const sumSquaresAndProduct = newSupply.sqr().add(newSupply.mul(currentSupply)).add(currentSupply.sqr());
    const cubicDelta = diff.mul(sumSquaresAndProduct);
    // integral term: (S1^3 - S0^3) / (3 * constant * M^2)
    const denom = THREE.mul(constant).mul(decimalFactor.sqr());
    const cubicCost = cubicDelta.div(denom);
    // linear term: basePrice * amount / M
    const linearCost = basePrice.mul(amount).div(decimalFactor);
    return cubicCost.add(linearCost);
}
function calcFee({ reserveAmount, feeRate }) {
    return new index_1.BN(reserveAmount).mul(new index_1.BN(feeRate)).div(new index_1.BN(10000));
}
function calcPrice({ currentSupply, decimal, curve }) {
    const calculator = {
        constant: () => calcConstantPrice({ currentSupply, decimal, ...curve }),
        linear: () => calcLinearPrice({ currentSupply, decimal, ...curve }),
        quadratic: () => calcQuadraticPrice({ currentSupply, decimal, ...curve }),
    }[curve.type];
    if (!calculator) {
        throw new Error('INVALID_CURVE_TYPE');
    }
    return calculator();
}
function calcCost({ amount, decimal, currentSupply, direction, curve, }) {
    const calculator = {
        constant: () => calcConstantCost({ amount, decimal, ...curve }),
        linear: () => calcLinearCost({ amount, decimal, currentSupply, direction, ...curve }),
        quadratic: () => calcQuadraticCost({ amount, decimal, currentSupply, direction, ...curve }),
    }[curve.type];
    if (!calculator) {
        throw new Error('INVALID_CURVE_TYPE');
    }
    return calculator();
}
