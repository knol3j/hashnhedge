import { BN } from './index';
const ZERO = new BN(0);
const TWO = new BN(2);
const THREE = new BN(3);
const TEN = new BN(10);
export var Direction;
(function (Direction) {
    Direction["Mint"] = "mint";
    Direction["Burn"] = "burn";
})(Direction || (Direction = {}));
/**
 * Constant Curve
 * Price = fixedPrice
 */
export function calcConstantPrice({ fixedPrice }) {
    return new BN(fixedPrice);
}
/**
 * Constant Curve
 * Cost = amount * fixedPrice
 */
export function calcConstantCost({ amount, fixedPrice, decimal, }) {
    const decimalFactor = TEN.pow(new BN(decimal));
    return new BN(amount).mul(new BN(fixedPrice)).div(decimalFactor);
}
/**
 * linear Curve
 * Price = basePrice + slope * currentSupply
 */
export function calcLinearPrice({ basePrice, slope, currentSupply, decimal, }) {
    const decimalFactor = TEN.pow(new BN(decimal));
    return new BN(basePrice).add(new BN(slope).mul(new BN(currentSupply)).div(decimalFactor));
}
/**
 * Linear Curve
 * mint Cost = (slope / 2) * ( (currentSupply + amount) ** 2 - currentSupply ** 2 ) + basePrice * amount;
 * burn Cost = (slope / 2) * ( currentSupply ** 2 - (currentSupply - amount) ** 2 ) + basePrice * amount;
 */
export function calcLinearCost(params) {
    const amount = new BN(params.amount);
    const currentSupply = new BN(params.currentSupply);
    const basePrice = new BN(params.basePrice);
    const slope = new BN(params.slope);
    const decimalFactor = TEN.pow(new BN(params.decimal));
    if (slope.lte(ZERO))
        throw new Error('INVALID_SLOPE');
    if (amount.lt(ZERO))
        throw new Error('INVALID_AMOUNT');
    if (currentSupply.lt(ZERO))
        throw new Error('INVALID_CURRENT_SUPPLY');
    if (basePrice.lt(ZERO))
        throw new Error('INVALID_BASE_PRICE');
    if (decimalFactor.lte(ZERO))
        throw new Error('INVALID_DECIMAL_FACTOR');
    if (params.direction === Direction.Burn && amount.gt(currentSupply)) {
        throw new Error('SUPPLY_INSUFFICIENT');
    }
    const integralDelta = params.direction === Direction.Mint
        ? amount.mul(currentSupply.mul(TWO).add(amount)) // (currentSupply + amount) ** 2 - currentSupply ** 2 = amount * (2 * currentSupply + amount)
        : amount.mul(currentSupply.mul(TWO).sub(amount)); // currentSupply ** 2 - (currentSupply - amount) ** 2 = amount * (2 * currentSupply - amount)
    const linearTerm = basePrice.mul(amount).div(decimalFactor);
    const integralTerm = slope.mul(integralDelta).div(TWO.mul(decimalFactor.sqr()));
    return linearTerm.add(integralTerm);
}
/**
 * Quadratic Curve
 * Price = basePrice + currentSupply ** 2 / constant
 */
export function calcQuadraticPrice(params) {
    const basePrice = new BN(params.basePrice);
    const currentSupply = new BN(params.currentSupply);
    const constant = new BN(params.constant);
    const decimalFactor = TEN.pow(new BN(params.decimal)); // 10^decimal
    if (constant.lte(ZERO))
        throw new Error('INVALID_CONSTANT');
    if (currentSupply.lt(ZERO))
        throw new Error('INVALID_CURRENT_SUPPLY');
    if (basePrice.lt(ZERO))
        throw new Error('INVALID_BASE_PRICE');
    if (decimalFactor.lte(ZERO))
        throw new Error('INVALID_DECIMAL_FACTOR');
    // Single division to reduce double-flooring error
    const denom = constant.mul(decimalFactor);
    const a = currentSupply.sqr().div(denom);
    return basePrice.add(a);
}
/**
 * Quadratic Curve
 * Price = basePrice + currentSupply ** 2 / constant
 * mint Cost = ( (currentSupply + amount)^3 / 3 - currentSupply^3 / 3 ) / constant + basePrice * amount;
 * burn Cost = ( currentSupply^3 / 3 - (currentSupply - amount)^3 / 3 ) / constant + basePrice * amount;
 */
export function calcQuadraticCost(params) {
    const amount = new BN(params.amount);
    const currentSupply = new BN(params.currentSupply);
    const basePrice = new BN(params.basePrice);
    const constant = new BN(params.constant);
    const decimalFactor = TEN.pow(new BN(params.decimal)); // M = 10^decimal
    // Basic validations
    if (constant.lte(ZERO))
        throw new Error('INVALID_CONSTANT');
    if (amount.lt(ZERO))
        throw new Error('INVALID_AMOUNT');
    if (amount.isZero())
        return ZERO;
    // Compute new supply with direction guard
    const newSupply = params.direction === Direction.Mint ? currentSupply.add(amount) : currentSupply.sub(amount);
    if (params.direction === Direction.Burn && newSupply.lt(ZERO)) {
        throw new Error('SUPPLY_INSUFFICIENT');
    }
    // cubicDelta = |S1^3 - S0^3| = (S1 - S0) * (S1^2 + S1 * S0 + S0^2)
    const diff = params.direction === Direction.Mint ? newSupply.sub(currentSupply) : currentSupply.sub(newSupply);
    const sumSquaresAndProduct = newSupply.sqr().add(newSupply.mul(currentSupply)).add(currentSupply.sqr());
    const cubicDelta = diff.mul(sumSquaresAndProduct);
    // integral term: (S1^3 - S0^3) / (3 * constant * M^2)
    const denom = THREE.mul(constant).mul(decimalFactor.sqr());
    const cubicCost = cubicDelta.div(denom);
    // linear term: basePrice * amount / M
    const linearCost = basePrice.mul(amount).div(decimalFactor);
    return cubicCost.add(linearCost);
}
export function calcFee({ reserveAmount, feeRate }) {
    return new BN(reserveAmount).mul(new BN(feeRate)).div(new BN(10000));
}
export function calcPrice({ currentSupply, decimal, curve }) {
    const calculator = {
        constant: () => calcConstantPrice({ currentSupply, decimal, ...curve }),
        linear: () => calcLinearPrice({ currentSupply, decimal, ...curve }),
        quadratic: () => calcQuadraticPrice({ currentSupply, decimal, ...curve }),
    }[curve.type];
    if (!calculator) {
        throw new Error('INVALID_CURVE_TYPE');
    }
    return calculator();
}
export function calcCost({ amount, decimal, currentSupply, direction, curve, }) {
    const calculator = {
        constant: () => calcConstantCost({ amount, decimal, ...curve }),
        linear: () => calcLinearCost({ amount, decimal, currentSupply, direction, ...curve }),
        quadratic: () => calcQuadraticCost({ amount, decimal, currentSupply, direction, ...curve }),
    }[curve.type];
    if (!calculator) {
        throw new Error('INVALID_CURVE_TYPE');
    }
    return calculator();
}
