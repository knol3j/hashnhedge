/* eslint-disable @typescript-eslint/no-useless-constructor */
import tweetnacl from 'tweetnacl';
import randomBytes from 'randombytes';
import { toUint8Array } from '@ocap/util';
import BaseSigner from '../protocols/signer';
import { encode } from '../encode';
const ed25519 = tweetnacl.sign;
/**
 * Signer implementation for ed25519, based on `tweetnacl`
 *
 * @class Ed25519Signer
 */
class Ed25519Signer extends BaseSigner {
    constructor() {
        super();
    }
    /**
     * @public
     * @typedefKeyPairType
     * @prop {string} publicKey - publicKey in hex format
     * @prop {string} secretKey - secretKey in hex format
     * @memberof Ed25519Signer
     */
    /**
     * Generate random secret/public key pair
     *
     * @param {Buffer|Uint8Array} [userSeed=undefined]
     * @param {string} [encoding='hex']
     * @returns {KeyPairType}
     * @memberof Ed25519Signer
     */
    genKeyPair(encoding = 'hex', userSeed) {
        const seed = userSeed ? toUint8Array(userSeed) : new Uint8Array(randomBytes(32));
        if (seed.byteLength !== 32) {
            throw new Error('Invalid seed to generate key pair');
        }
        const keyPair = ed25519.keyPair.fromSeed(seed);
        keyPair.publicKey = encode(keyPair.publicKey, encoding);
        keyPair.secretKey = encode(keyPair.secretKey, encoding);
        return keyPair;
    }
    /**
     * Get publicKey from secretKey
     *
     * @param {hex|buffer|base58|Uint8Array} sk - can be either a hex encoded string or a buffer
     * @returns {string} hex encoded publicKey
     */
    getPublicKey(sk, encoding = 'hex') {
        const skBytes = toUint8Array(sk);
        const pk = ed25519.keyPair.fromSecretKey(skBytes).publicKey;
        return encode(pk, encoding);
    }
    /**
     * Sign a message and get the signature hex
     *
     * @param {hex|base58|buffer|Uint8Array} message
     * @param {hex|base58|buffer|Uint8Array} sk
     * @returns {string} hex encoded signature
     */
    sign(message, sk, encoding = 'hex') {
        const skBytes = toUint8Array(sk);
        const messageBytes = toUint8Array(message);
        const signature = ed25519.detached(messageBytes, skBytes);
        return encode(signature, encoding);
    }
    /**
     * Verify if a signature is valid
     *
     * @param {string|buffer} message
     * @param {string|buffer} signature
     * @param {string|buffer} pk
     * @returns {bool}
     */
    verify(message, signature, pk) {
        const pkBytes = toUint8Array(pk);
        const messageBytes = toUint8Array(message);
        const signatureBytes = toUint8Array(signature);
        return ed25519.detached.verify(messageBytes, signatureBytes, pkBytes);
    }
}
export default new Ed25519Signer();
export { Ed25519Signer };
