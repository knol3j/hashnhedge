/* eslint-disable @typescript-eslint/no-useless-constructor */
import { toBuffer, fromBase64, toBase64 } from '@ocap/util';
import { decodeClientDataJSON, isoBase64URL, isoUint8Array, toHash, verifySignature, } from '@simplewebauthn/server/helpers';
import BaseSigner from '../protocols/signer';
/**
 * Signer implementation for passkey, based on `@simplewebauthn/server`
 * Since passkey supports only verification, we do not need to implement the sign method
 * And passkeys can used multiple algorithms, we do not need to implement the algorithm selection
 *
 * @class PasskeySigner
 */
class PasskeySigner extends BaseSigner {
    constructor() {
        super();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    genKeyPair(encoding = 'hex', userSeed) {
        throw new Error('Not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPublicKey(sk, encoding = 'hex') {
        throw new Error('Not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign(message, sk, encoding = 'hex') {
        throw new Error('Not supported');
    }
    /**
     * Verify if a signature is valid
     *
     * @param {string|buffer} challenge - the challenge sent to passkey, should be txHash when signing a transaction
     * @param {string|buffer} signature - signature from passkey
     * @param {string|buffer} pk - credentialPublicKey from passkey, must be parsed with `parseAuthenticatorData`
     * @returns {bool}
     */
    async verify(challenge, signature, pk, extra) {
        const parsed = JSON.parse(extra);
        if (!parsed.authenticatorData || !parsed.clientDataJSON) {
            throw new Error('extra.authenticatorData or extra.clientDataJSON is required for passkey signature verification');
        }
        const authDataBuffer = toBuffer(fromBase64(parsed.authenticatorData));
        const clientDataHash = await toHash(isoBase64URL.toBuffer(parsed.clientDataJSON));
        const clientData = decodeClientDataJSON(parsed.clientDataJSON);
        if (clientData.challenge !== toBase64(challenge)) {
            throw new Error('challenge mismatch for passkey signature');
        }
        // FIXME: @wangshijun add more check here
        // if (clientData.type !== 'ocap.tx.sign') {
        //   throw new Error('Invalid client data type');
        // }
        return verifySignature({
            signature: isoBase64URL.toBuffer(typeof signature === 'string' ? signature : toBase64(signature)),
            data: isoUint8Array.concat([authDataBuffer, clientDataHash]),
            credentialPublicKey: pk,
        });
    }
}
export default new PasskeySigner();
export { PasskeySigner };
