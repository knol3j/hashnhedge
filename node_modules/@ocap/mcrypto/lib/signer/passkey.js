"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasskeySigner = void 0;
/* eslint-disable @typescript-eslint/no-useless-constructor */
const util_1 = require("@ocap/util");
const helpers_1 = require("@simplewebauthn/server/helpers");
const signer_1 = __importDefault(require("../protocols/signer"));
/**
 * Signer implementation for passkey, based on `@simplewebauthn/server`
 * Since passkey supports only verification, we do not need to implement the sign method
 * And passkeys can used multiple algorithms, we do not need to implement the algorithm selection
 *
 * @class PasskeySigner
 */
class PasskeySigner extends signer_1.default {
    constructor() {
        super();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    genKeyPair(encoding = 'hex', userSeed) {
        throw new Error('Not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPublicKey(sk, encoding = 'hex') {
        throw new Error('Not supported');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sign(message, sk, encoding = 'hex') {
        throw new Error('Not supported');
    }
    /**
     * Verify if a signature is valid
     *
     * @param {string|buffer} challenge - the challenge sent to passkey, should be txHash when signing a transaction
     * @param {string|buffer} signature - signature from passkey
     * @param {string|buffer} pk - credentialPublicKey from passkey, must be parsed with `parseAuthenticatorData`
     * @returns {bool}
     */
    async verify(challenge, signature, pk, extra) {
        const parsed = JSON.parse(extra);
        if (!parsed.authenticatorData || !parsed.clientDataJSON) {
            throw new Error('extra.authenticatorData or extra.clientDataJSON is required for passkey signature verification');
        }
        const authDataBuffer = (0, util_1.toBuffer)((0, util_1.fromBase64)(parsed.authenticatorData));
        const clientDataHash = await (0, helpers_1.toHash)(helpers_1.isoBase64URL.toBuffer(parsed.clientDataJSON));
        const clientData = (0, helpers_1.decodeClientDataJSON)(parsed.clientDataJSON);
        if (clientData.challenge !== (0, util_1.toBase64)(challenge)) {
            throw new Error('challenge mismatch for passkey signature');
        }
        // FIXME: @wangshijun add more check here
        // if (clientData.type !== 'ocap.tx.sign') {
        //   throw new Error('Invalid client data type');
        // }
        return (0, helpers_1.verifySignature)({
            signature: helpers_1.isoBase64URL.toBuffer(typeof signature === 'string' ? signature : (0, util_1.toBase64)(signature)),
            data: helpers_1.isoUint8Array.concat([authDataBuffer, clientDataHash]),
            credentialPublicKey: pk,
        });
    }
}
exports.PasskeySigner = PasskeySigner;
exports.default = new PasskeySigner();
